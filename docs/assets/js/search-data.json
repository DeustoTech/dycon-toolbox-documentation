{
  "0": {
    "id": "0",
    "title": "Download",
    "content": "DyCon Toolbox is open source, compatible with MATLAB 9.3 (R2017b) or later, and is freely available on Github. Direct Download Download by following link: DyCon Toolbox (.zip) Download from MATLAB Alternatively you can start using DyCon Toolbox by simply pasting the code below to your MATLAB command window &gt;&gt; unzip(&#39;https://github.com/DeustoTech/DyCon-Computational-Platform/archive/master.zip&#39;) &gt;&gt; addpath(genpath(fullfile(cd,&#39;DyCon-toolbox-master&#39;))) Download from Github If you rather prefer to clone the repository directly from Github, you can do it by typing the following command at a terminal: git clone https://github.com/DeustoTech/DyCon-Computational-Platform.git Give us your feedback Please if you find any bug or have questions, do not hesitate to contact us. You can give us your feedback through this email address (dycon-dev-group@deusto.es). Get started To get started we encourage you to visit First Steps where the basic features of DyCon Toolbox are explained. Then we suggest you to check any of our Tutorials.",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/02-Download/",
    "relUrl": "/posts/02-Download/"
  },
  "1": {
    "id": "1",
    "title": "Examples",
    "content": "One of the great contributions of DyCon Toolbox are the examples provided by the team of the Chair of Computational Mathematics. These examples are on the DyCon Blog web platform, where the Chair of Computational Mathematics team publish different software tutorials including DyCon toolbox tutorials. The Optimal control on the Kuramoto adaptative coupling model with DyCon Toolbox In this DyCon Toolbox tutorial, we present how to use OptimaControl enviroment to control a consensus that models the complex emergent dynamics over a given network. read more ... Simultaneous Control with DyCon Toolbox In this tutorial we will present a simultaneous control problem in a linear system dependent on parameters. We will use the MATLAb DyCon Toolbox library. read more ... Stabilization of a double pendulum on a cart with DyCon Toolbox In this blog post, we consider a double pendulum on a cart and we solve the problem of swinging up the pendulum from the downward position to the upward position using optimal control techniques. read more ... Control for a semilinear heat equation and analogies with a collective behavior model In this tutorial we will apply the DyCon toolbox to find a control to the semi-discrete semi-linear heat equation. read more ... Simulation of Fractional Heat Equation In this tutorial, we show the simulation of heat fractional equation read more ...",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/05-Examples/06-Examples/",
    "relUrl": "/posts/05-Examples/06-Examples/"
  },
  "3": {
    "id": "3",
    "title": "Fractional Laplacian Dynamics",
    "content": "We use DyCon Toolbox for solving numerically the following control problem: given any $T&gt;0$, find a control function $g in L^2( ( -1 , 1) times (0,T))$ such that the corresponding solution to the parabolic problem satisfies $z(x,T)=0$. Here, for all $s in(0,1)$, $(-d_x^2)^s$ denotes the one-dimensional fractional Laplace operator, defined as the following singular integral Discretization of the problem As a first thing, we need to discretize eqref{frac_heat}. Hence, let us consider a uniform N-points mesh on the interval $(-1,1)$. N = 70; xi = -1; xf = 1; xline = linspace(xi,xf,N+2); xline = xline(2:end-1); Out of that, we can construct the FE approxiamtion of the fractional Lapalcian, using the program FEFractionalLaplacian developped by our team, which implements the methodology described in [1]. s = 0.8; A = -FEFractionalLaplacian(s,1,N); M = MassMatrix(xline); Moreover, we build the matrix $B$ defining the action of the control, by using the program “BInterior” (see below). a = -0.3; b = 0.8; B = BInterior(xline,a,b,&#39;Mass&#39;,true); We can then define a final time and an initial datum FinalTime = 2; Y0 =sin(pi*xline&#39;); and construct the system tspan = linspace(0,FinalTime,200); dynamics = linearpde1d(A,B,tspan,xline); dynamics.InitialCondition = Y0; dynamics.MassMatrix = M; Y0 =cos(pi*xline&#39;); Y0(xline &gt; 0.2) = 0; Y0(xline &lt; -0.2) = 0; dynamics.InitialCondition = Y0; U0 = ZerosControl(dynamics); solve(dynamics,U0); ssline = linspace(0.01,0.99,10); iter = 0; for s = ssline iter = iter + 1; A = -FEFractionalLaplacian(s,1,N); dynamics.A = A; [Ysolution] = solve(dynamics,U0); Data(iter).Y = Ysolution&#39;; end %%animation_FLD(ssline,Data,xline) References [1] U. Biccari and V. Hern&#39;andez-Santamar&#39;ia - textit{Controllability of a one-dimensional fractional heat equation: theoretical and numerical aspects}, IMA J. Math. Control. Inf., to appear",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/05-Examples/PDE/T0001_FractionalLaplacianDynamics/",
    "relUrl": "/posts/05-Examples/PDE/T0001_FractionalLaplacianDynamics/"
  },
  "4": {
    "id": "4",
    "title": "Simulation of Fractional Laplacian",
    "content": "We use DyCon Toolbox to solve numerically the following fractional heat equation: Here, for all $s in(0,1)$, $(-d_x^2)^s$ denotes the one-dimensional fractional Laplace operator, defined as the following singular integral Discretization of the problem As a first thing, we need to discretize eqref{frac_heat}. Hence, let us consider a uniform N-points mesh on the interval $(-1,1)$. N = 50; xi = -1; xf = 1; xline = linspace(xi,xf,N+2); xline = xline(2:end-1); Out of that, we can construct the FE approximation of the fractional Laplacian, using the program FEFractionalLaplacian developed by our team, which implements the methodology described in [1]. s = 0.8; A = -FEFractionalLaplacian(s,1,N); Moreover, we build the mass matrix $M$ associated to our mesh. M = MassMatrix(xline); We can then define a time horizon for our simulations and an initial datum FinalTime = 0.5; Y0 =cos(pi*xline&#39;); Y0(xline &gt; 0.2) = 0; Y0(xline &lt; -0.2) = 0; and construct the system dynamics = pde(&#39;A&#39;,A,&#39;InitialCondition&#39;,Y0,&#39;FinalTime&#39;,FinalTime,&#39;Nt&#39;,100); dynamics.mesh = xline; dynamics.MassMatrix = M; dynamics.InitialCondition = Y0; solve(dynamics); We can launch several simulations for different values of “s” ssline = linspace(0.01,0.99,14); iter = 0; for s = ssline iter = iter + 1; A = -FEFractionalLaplacian(s,1,N); dynamics.A = A; [tspan,Ysolution] = solve(dynamics); Data(iter).Y = Ysolution; end animation_FLD(ssline,Data,xline) This simulation clearly show how the diffusivity of the equation is strongly affected by the power of the fractional Laplacian being, in particular, very low for small values of $s$. This behavior then affects the controllability properties of eqref{frac_heat}, as it is discussed in [1]. References [1] U. Biccari and V. Hernández-Santamaría - Controllability of a one-dimensional fractional heat equation: theoretical and numerical aspects, IMA J. Math. Control. Inf., to appear",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/05-Examples/T0001_FractionalLaplacianDynamics/",
    "relUrl": "/posts/05-Examples/T0001_FractionalLaplacianDynamics/"
  },
  "5": {
    "id": "5",
    "title": "ode",
    "content": "MATLAB class to represents a dynamical systems. Constructor Inputs Name Class Description dyn &#39;casadi.Function&#39; It is a casadi object that define the dynamics equation $ mathbb{R}^+ times mathcal{X} times mathcal{U} rightarrow S$ of ODE. State &#39;casadi.SX&#39; It is a symbolical variable that represent the state $x in mathcal{X}$ Control &#39;casadi.SX&#39; It is a symbolical variable that represent the control $u in mathcal{U}$ tspan &#39;double&#39; It is a list of times in which the dynamics will be solved. Outputs Name Class Description iode &#39;ode&#39; It is a DyCon Toolbox object to represent a ODE. import casadi.* % define the symbolical variables Xs = SX.sym(&#39;x&#39;,2,1); Us = SX.sym(&#39;u&#39;,2,1); ts = SX.sym(&#39;ts&#39;); % define the dynamics dyn = casadi.Function(&#39;f&#39;,{ts,Xs,Us},{ -cos(1*pi*Xs) + 2*sin(ts)+ Us }); % choose the time discretization T = 5; tspan = linspace(0,T,50); % create the ode object isys = ode(dyn,Xs,Us,tspan);",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/ode/T031_ode/",
    "relUrl": "/posts/03-DynamicsInterface/ode/T031_ode/"
  },
  "6": {
    "id": "6",
    "title": "SetIntegrator",
    "content": "Mandatory Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve method &#39;double&#39; This is the integrator method. This parameter must be member of this: {&quot;casadi&quot;,&quot;BackwardEuler&quot;,&quot;RK4&quot;,&quot;LinearFordwardEuler&quot;,&quot;SemiLinearFordwardEuler&quot;} Method parameter is a procedure for solving ordinary differential equations (ODEs) with a given initial value. casadi BackwardEuler RK4 LinearFordwardEuler SemiLinearFordwardEuler",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/ode/T031_ode_SetIntegrator/",
    "relUrl": "/posts/03-DynamicsInterface/ode/T031_ode_SetIntegrator/"
  },
  "7": {
    "id": "7",
    "title": "solve",
    "content": "Method to compute the solution of ode. Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve Ut &#39;double&#39; control matrix with dimensions: $length(iode.Control.sym) times length(iode.tspan)$ Outputs Name Class Description xt &#39;casadi.DM&#39; Solution matrix of dynamic Set Initial condition and solve with null control isys.InitialCondition = [1;2]; %% u0 = ZerosControl(isys); xt = solve(isys,u0); &gt;&gt; xt xt = [[1, 1.04836, 1.11048, 1.18304, 1.26235, 1.34514, 1.42928, 1.51405, 1.6002, 1.68993, 1.78677, 1.89505, 2.01814, 2.15537, 2.30011, 2.44214, 2.57263, 2.68709, 2.78486, 2.86728, 2.93617, 2.99313, 3.03933, 3.07571, 3.10323, 3.12288, 3.1351, 3.13936, 3.1343, 3.1182, 3.08947, 3.04696, 2.99041, 2.92077, 2.8404, 2.75286, 2.66222, 2.57216, 2.4853, 2.40305, 2.3257, 2.25281, 2.18348, 2.11652, 2.05052, 1.98377, 1.91406, 1.83838, 1.7527, 1.65257], [2, 1.96534, 1.94318, 1.93408, 1.93823, 1.95569, 1.9867, 2.03195, 2.09268, 2.17052, 2.26654, 2.37936, 2.50337, 2.62978, 2.75065, 2.86189, 2.96328, 3.05695, 3.14606, 3.23424, 3.32557, 3.42472, 3.53663, 3.66457, 3.80584, 3.94916, 4.07981, 4.18796, 4.27088, 4.33014, 4.36863, 4.38928, 4.39463, 4.38698, 4.36842, 4.34092, 4.3063, 4.26612, 4.22162, 4.17368, 4.12274, 4.06884, 4.01152, 3.9498, 3.88195, 3.80526, 3.71565, 3.60759, 3.47567, 3.31994]] &gt;&gt; class(xt) ans = &#39;casadi.DM&#39;",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/ode/T031_ode_solve/",
    "relUrl": "/posts/03-DynamicsInterface/ode/T031_ode_solve/"
  },
  "8": {
    "id": "8",
    "title": "pde1d",
    "content": "MATLAB class to represents a dynamical systems. Constructor Inputs Name Class Description dyn &#39;casadi.Function&#39; It is a casadi object that define the dynamics equation $ mathbb{R}^+ times mathcal{X} times mathcal{U} rightarrow S$ of ODE. State &#39;casadi.SX&#39; It is a symbolical variable that represent the state $x in mathcal{X}$ Control &#39;casadi.SX&#39; It is a symbolical variable that represent the control $u in mathcal{U}$ tspan &#39;double&#39; It is a list of times in which the dynamics will be solved. Outputs Name Class Description iode &#39;ode&#39; It is a DyCon Toolbox object to represent a ODE. import casadi.* % define the symbolical variables Xs = SX.sym(&#39;x&#39;,2,1); Us = SX.sym(&#39;u&#39;,2,1); ts = SX.sym(&#39;ts&#39;); % define the dynamics dyn = casadi.Function(&#39;f&#39;,{ts,Xs,Us},{ -cos(1*pi*Xs) + 2*sin(ts)+ Us }); % choose the time discretization T = 5; tspan = linspace(0,T,50); % create the ode object isys = ode(dyn,Xs,Us,tspan);",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde1d/T032_pde1d/",
    "relUrl": "/posts/03-DynamicsInterface/pde1d/T032_pde1d/"
  },
  "9": {
    "id": "9",
    "title": "SetIntegrator",
    "content": "Mandatory Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve method &#39;double&#39; This is the integrator method. This parameter must be member of this: {&quot;casadi&quot;,&quot;BackwardEuler&quot;,&quot;RK4&quot;,&quot;LinearFordwardEuler&quot;,&quot;SemiLinearFordwardEuler&quot;} Method parameter is a procedure for solving ordinary differential equations (ODEs) with a given initial value. casadi BackwardEuler RK4 LinearFordwardEuler SemiLinearFordwardEuler",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde1d/T032_pde1d_SetIntegrator/",
    "relUrl": "/posts/03-DynamicsInterface/pde1d/T032_pde1d_SetIntegrator/"
  },
  "10": {
    "id": "10",
    "title": "solve",
    "content": "Method to compute the solution of ode. Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve Ut &#39;double&#39; control matrix with dimensions: $length(iode.Control.sym) times length(iode.tspan)$ Outputs Name Class Description xt &#39;casadi.DM&#39; Solution matrix of dynamic Set Initial condition and solve with null control isys.InitialCondition = [1;2]; %% u0 = ZerosControl(isys); xt = solve(isys,u0); &gt;&gt; xt xt = [[1, 1.04836, 1.11048, 1.18304, 1.26235, 1.34514, 1.42928, 1.51405, 1.6002, 1.68993, 1.78677, 1.89505, 2.01814, 2.15537, 2.30011, 2.44214, 2.57263, 2.68709, 2.78486, 2.86728, 2.93617, 2.99313, 3.03933, 3.07571, 3.10323, 3.12288, 3.1351, 3.13936, 3.1343, 3.1182, 3.08947, 3.04696, 2.99041, 2.92077, 2.8404, 2.75286, 2.66222, 2.57216, 2.4853, 2.40305, 2.3257, 2.25281, 2.18348, 2.11652, 2.05052, 1.98377, 1.91406, 1.83838, 1.7527, 1.65257], [2, 1.96534, 1.94318, 1.93408, 1.93823, 1.95569, 1.9867, 2.03195, 2.09268, 2.17052, 2.26654, 2.37936, 2.50337, 2.62978, 2.75065, 2.86189, 2.96328, 3.05695, 3.14606, 3.23424, 3.32557, 3.42472, 3.53663, 3.66457, 3.80584, 3.94916, 4.07981, 4.18796, 4.27088, 4.33014, 4.36863, 4.38928, 4.39463, 4.38698, 4.36842, 4.34092, 4.3063, 4.26612, 4.22162, 4.17368, 4.12274, 4.06884, 4.01152, 3.9498, 3.88195, 3.80526, 3.71565, 3.60759, 3.47567, 3.31994]] &gt;&gt; class(xt) ans = &#39;casadi.DM&#39;",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde1d/T032_pde1d_solve/",
    "relUrl": "/posts/03-DynamicsInterface/pde1d/T032_pde1d_solve/"
  },
  "11": {
    "id": "11",
    "title": "pde2d",
    "content": "MATLAB class to represents a dynamical systems. Constructor Inputs Name Class Description dyn &#39;casadi.Function&#39; It is a casadi object that define the dynamics equation $ mathbb{R}^+ times mathcal{X} times mathcal{U} rightarrow S$ of ODE. State &#39;casadi.SX&#39; It is a symbolical variable that represent the state $x in mathcal{X}$ Control &#39;casadi.SX&#39; It is a symbolical variable that represent the control $u in mathcal{U}$ tspan &#39;double&#39; It is a list of times in which the dynamics will be solved. Outputs Name Class Description iode &#39;ode&#39; It is a DyCon Toolbox object to represent a ODE. import casadi.* % define the symbolical variables Xs = SX.sym(&#39;x&#39;,2,1); Us = SX.sym(&#39;u&#39;,2,1); ts = SX.sym(&#39;ts&#39;); % define the dynamics dyn = casadi.Function(&#39;f&#39;,{ts,Xs,Us},{ -cos(1*pi*Xs) + 2*sin(ts)+ Us }); % choose the time discretization T = 5; tspan = linspace(0,T,50); % create the ode object isys = ode(dyn,Xs,Us,tspan);",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde2d/T033_pde2d/",
    "relUrl": "/posts/03-DynamicsInterface/pde2d/T033_pde2d/"
  },
  "12": {
    "id": "12",
    "title": "SetIntegrator",
    "content": "Mandatory Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve method &#39;double&#39; This is the integrator method. This parameter must be member of this: {&quot;casadi&quot;,&quot;BackwardEuler&quot;,&quot;RK4&quot;,&quot;LinearFordwardEuler&quot;,&quot;SemiLinearFordwardEuler&quot;} Method parameter is a procedure for solving ordinary differential equations (ODEs) with a given initial value. casadi BackwardEuler RK4 LinearFordwardEuler SemiLinearFordwardEuler",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde2d/T033_pde2d_SetIntegrator/",
    "relUrl": "/posts/03-DynamicsInterface/pde2d/T033_pde2d_SetIntegrator/"
  },
  "13": {
    "id": "13",
    "title": "solve",
    "content": "Method to compute the solution of ode. Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve Ut &#39;double&#39; control matrix with dimensions: $length(iode.Control.sym) times length(iode.tspan)$ Outputs Name Class Description xt &#39;casadi.DM&#39; Solution matrix of dynamic Set Initial condition and solve with null control isys.InitialCondition = [1;2]; %% u0 = ZerosControl(isys); xt = solve(isys,u0); &gt;&gt; xt xt = [[1, 1.04836, 1.11048, 1.18304, 1.26235, 1.34514, 1.42928, 1.51405, 1.6002, 1.68993, 1.78677, 1.89505, 2.01814, 2.15537, 2.30011, 2.44214, 2.57263, 2.68709, 2.78486, 2.86728, 2.93617, 2.99313, 3.03933, 3.07571, 3.10323, 3.12288, 3.1351, 3.13936, 3.1343, 3.1182, 3.08947, 3.04696, 2.99041, 2.92077, 2.8404, 2.75286, 2.66222, 2.57216, 2.4853, 2.40305, 2.3257, 2.25281, 2.18348, 2.11652, 2.05052, 1.98377, 1.91406, 1.83838, 1.7527, 1.65257], [2, 1.96534, 1.94318, 1.93408, 1.93823, 1.95569, 1.9867, 2.03195, 2.09268, 2.17052, 2.26654, 2.37936, 2.50337, 2.62978, 2.75065, 2.86189, 2.96328, 3.05695, 3.14606, 3.23424, 3.32557, 3.42472, 3.53663, 3.66457, 3.80584, 3.94916, 4.07981, 4.18796, 4.27088, 4.33014, 4.36863, 4.38928, 4.39463, 4.38698, 4.36842, 4.34092, 4.3063, 4.26612, 4.22162, 4.17368, 4.12274, 4.06884, 4.01152, 3.9498, 3.88195, 3.80526, 3.71565, 3.60759, 3.47567, 3.31994]] &gt;&gt; class(xt) ans = &#39;casadi.DM&#39;",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pde2d/T033_pde2d_solve/",
    "relUrl": "/posts/03-DynamicsInterface/pde2d/T033_pde2d_solve/"
  },
  "14": {
    "id": "14",
    "title": "pdefem",
    "content": "MATLAB class to represents a dynamical systems. Constructor Inputs Name Class Description dyn &#39;casadi.Function&#39; It is a casadi object that define the dynamics equation $ mathbb{R}^+ times mathcal{X} times mathcal{U} rightarrow S$ of ODE. State &#39;casadi.SX&#39; It is a symbolical variable that represent the state $x in mathcal{X}$ Control &#39;casadi.SX&#39; It is a symbolical variable that represent the control $u in mathcal{U}$ tspan &#39;double&#39; It is a list of times in which the dynamics will be solved. Outputs Name Class Description iode &#39;ode&#39; It is a DyCon Toolbox object to represent a ODE. import casadi.* % define the symbolical variables Xs = SX.sym(&#39;x&#39;,2,1); Us = SX.sym(&#39;u&#39;,2,1); ts = SX.sym(&#39;ts&#39;); % define the dynamics dyn = casadi.Function(&#39;f&#39;,{ts,Xs,Us},{ -cos(1*pi*Xs) + 2*sin(ts)+ Us }); % choose the time discretization T = 5; tspan = linspace(0,T,50); % create the ode object isys = ode(dyn,Xs,Us,tspan);",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pdefem/T033_pdefem/",
    "relUrl": "/posts/03-DynamicsInterface/pdefem/T033_pdefem/"
  },
  "15": {
    "id": "15",
    "title": "SetIntegrator",
    "content": "Mandatory Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve method &#39;double&#39; This is the integrator method. This parameter must be member of this: {&quot;casadi&quot;,&quot;BackwardEuler&quot;,&quot;RK4&quot;,&quot;LinearFordwardEuler&quot;,&quot;SemiLinearFordwardEuler&quot;} Method parameter is a procedure for solving ordinary differential equations (ODEs) with a given initial value. casadi BackwardEuler RK4 LinearFordwardEuler SemiLinearFordwardEuler",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pdefem/T033_pdefem_SetIntegrator/",
    "relUrl": "/posts/03-DynamicsInterface/pdefem/T033_pdefem_SetIntegrator/"
  },
  "16": {
    "id": "16",
    "title": "solve",
    "content": "Method to compute the solution of ode. Inputs Name Class Description iode &#39;ode&#39; ode object that you want solve Ut &#39;double&#39; control matrix with dimensions: $length(iode.Control.sym) times length(iode.tspan)$ Outputs Name Class Description xt &#39;casadi.DM&#39; Solution matrix of dynamic Set Initial condition and solve with null control isys.InitialCondition = [1;2]; %% u0 = ZerosControl(isys); xt = solve(isys,u0); &gt;&gt; xt xt = [[1, 1.04836, 1.11048, 1.18304, 1.26235, 1.34514, 1.42928, 1.51405, 1.6002, 1.68993, 1.78677, 1.89505, 2.01814, 2.15537, 2.30011, 2.44214, 2.57263, 2.68709, 2.78486, 2.86728, 2.93617, 2.99313, 3.03933, 3.07571, 3.10323, 3.12288, 3.1351, 3.13936, 3.1343, 3.1182, 3.08947, 3.04696, 2.99041, 2.92077, 2.8404, 2.75286, 2.66222, 2.57216, 2.4853, 2.40305, 2.3257, 2.25281, 2.18348, 2.11652, 2.05052, 1.98377, 1.91406, 1.83838, 1.7527, 1.65257], [2, 1.96534, 1.94318, 1.93408, 1.93823, 1.95569, 1.9867, 2.03195, 2.09268, 2.17052, 2.26654, 2.37936, 2.50337, 2.62978, 2.75065, 2.86189, 2.96328, 3.05695, 3.14606, 3.23424, 3.32557, 3.42472, 3.53663, 3.66457, 3.80584, 3.94916, 4.07981, 4.18796, 4.27088, 4.33014, 4.36863, 4.38928, 4.39463, 4.38698, 4.36842, 4.34092, 4.3063, 4.26612, 4.22162, 4.17368, 4.12274, 4.06884, 4.01152, 3.9498, 3.88195, 3.80526, 3.71565, 3.60759, 3.47567, 3.31994]] &gt;&gt; class(xt) ans = &#39;casadi.DM&#39;",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/pdefem/T033_pdefem_solve/",
    "relUrl": "/posts/03-DynamicsInterface/pdefem/T033_pdefem_solve/"
  },
  "17": {
    "id": "17",
    "title": "Dynamics definition",
    "content": "Example of dynamic In dynamics, the Van der Pol oscillator is a non-conservative oscillator with non-linear damping. It evolves in time according to the second-order differential equation: In vectorial form : &gt;&gt; import casadi.* &gt;&gt; x = SX.sym(&#39;x&#39;,[1 1]); &gt;&gt; v = SX.sym(&#39;x&#39;,[1 1]); &gt;&gt; u = SX.sym(&#39;u&#39;,[1 1]); &gt;&gt; t = SX.sym(&#39;t&#39;); &gt;&gt; mu = 10; &gt;&gt; f = casadi.Function(&#39;f&#39;,{t,[x;v],u},{ [ v ; ... &gt;&gt; mu*(1-x^2)*v - x + u ] }); We can define the ode command to build a MATLAB object &gt;&gt; T = 5; &gt;&gt; Nt = 100; &gt;&gt; tspan = linspace(0,T,Nt); &gt;&gt; % Build a ode object &gt;&gt; idyn = ode(f,[x;v],u,tspan); &gt;&gt; idyn.InitialCondition = [2,4]&#39;; Inside this object, we have a lot information of dynamics Solve dynamics with zeros control &gt;&gt; u0 = ZerosControl(idyn); &gt;&gt; wt = solve(idyn,u0)",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/03-DynamicsInterface/T03_DynamicsInterface/",
    "relUrl": "/posts/03-DynamicsInterface/T03_DynamicsInterface/"
  },
  "18": {
    "id": "18",
    "title": "ArmijoGradient",
    "content": "DyCon toolbox adopts Pontryagin’s maximum principle to optimize the control function for each control problem. In this way we can solve problems of the form: subject to ‘Pontryagin’ class uses symbolic interface to define a control problem as in ‘ode’ class. ‘Pontryagin’ class contains ‘ode’ class, the final cost, and running cost. As ‘ode’ class contains $ f $, the final cost $ Psi $ and running cost $ L $ should be given by symbolic functions. Here we explain ‘Pontryagin’ class with a simple example: we want to minimize the objective function subject to The dynamics and cost functions are based on symbolic vectors $ Y $ and $ U $, which represent the state of the dynamics and control vector. Y = sym(&#39;y&#39;,[2 1]) Y = y1 y2 U = sym(&#39;u&#39;,[2 1]) U = u1 u2 The dynamics of $ Y $ should be given by a symbolic vector with the same dimensions as the state vector. Following the notation at the beginning, this vector represents $ f (t, Y, U) $: mu = param(&#39;mu&#39;,10); nu = param(&#39;nu&#39;,1); %% F = @(t,Y,U,Params) [ Y(1)*Y(2) + U(2)*Params(1) ; ... -Y(2) + U(1)*norm(Params(2)) ] ; Using this dynamics vector, we construct an ‘ode’ class. dynamics = ode(F,Y,U,[mu nu]); The printed information above shows the default setting of this ‘ode’ class. In order to construct the dynamics we want, we need to customize its parameters. In this case we change the initial condition for the dynamics and the sampling timestep. The time discretization is generated as a uniform mesh from the timestep $ dt $. It will be used not only for the sampling of the state vector $ Y $ but also to represent the control vector $ U $ and cost $ J $ in ‘Pontryagin’ class. dynamics.InitialCondition = [0; -1]; dynamics.Nt = 10; Next we need to define the functional $ J $ we want to minimize. Following the form presented in [1], we define the expressions of $ Psi $ and $ L $ in symbolic form: Psi = @(T,Y) Y.&#39;*Y; L = @(t,Y,U) 0.005*(U.&#39;*U); We finally define the optimal control problem as a ‘Pontryagin’ class: iP = Pontryagin(dynamics,Psi,L); This class contains information we need to find the optimal control vector $ U $. It is worth mentioning that until now we defined the problem but not solved it yet. iP iP = Pontryagin with properties: Target: [] Functional: [1x1 PontryaginFunctional] Dynamics: [1x1 ode] Adjoint: [1x1 struct] Hamiltonian: [1x1 SymNumFun] ControlGradient: [1x1 SymNumFun] Hessian: [1x1 SymNumFun] AnalyticalControl: [1x1 SymNumFun] Solution: [] Constraints: [1x1 constraints] DyCon toolbox uses the gradient methods to optimize the cost functional. This calculates the gradient of $ J $ along $ U $ from the first order approximation of the Hamiltonian and adjoint state vector in the Pontryagin principle. To solve the problem using the default gradient method, we simply write: U0 = zeros(iP.Dynamics.Nt,iP.Dynamics.ControlDimension); GradientMethod(iP,U0); Solve with precision: We obtain: J(u) = 1.148222E-03 error = 2.000023E-03 With 3 iterations, In 0.083441 seconds This command generates ‘solution’ in the ‘Pontryagin’ class, which contains the optimal control vector ‘UOptimal’ and its information, such as the cost, precision and time of computations. iP.Solution ans = solution with properties: precision: 0.0020 iter: 3 time: 0.0834 Y0history: [] Yhistory: {[10x2 double] [10x2 double] [10x2 double]} ControlHistory: {[10x2 double] [10x2 double] [10x2 double]} Jhistory: [0.1200 0.0011 0.0011] Phistory: {[10x2 double] [10x2 double] [10x2 double]} dJhistory: {[10x2 double] [10x2 double] [10x2 double]} fhistory: [] dfhistory: [] Ehistory: [0 0.0020 0.0020] timeline: [] du: [] UOptimal: [10x2 double] JOptimal: 0.0011 This structure is independent of the solver, and we can see the results through visualization functions we want. One of the examples is ‘plot’ function which can be applied to ‘Pontryagin’ class. plot(iP)",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/ocp/T041_ArmijoGradient/",
    "relUrl": "/posts/04-PontryaginProblems/ocp/T041_ArmijoGradient/"
  },
  "19": {
    "id": "19",
    "title": "ClassicalGradient",
    "content": "DyCon toolbox adopts Pontryagin’s maximum principle to optimize the control function for each control problem. In this way we can solve problems of the form: subject to ‘Pontryagin’ class uses symbolic interface to define a control problem as in ‘ode’ class. ‘Pontryagin’ class contains ‘ode’ class, the final cost, and running cost. As ‘ode’ class contains $ f $, the final cost $ Psi $ and running cost $ L $ should be given by symbolic functions. Here we explain ‘Pontryagin’ class with a simple example: we want to minimize the objective function subject to The dynamics and cost functions are based on symbolic vectors $ Y $ and $ U $, which represent the state of the dynamics and control vector. Y = sym(&#39;y&#39;,[2 1]) Y = y1 y2 U = sym(&#39;u&#39;,[2 1]) U = u1 u2 The dynamics of $ Y $ should be given by a symbolic vector with the same dimensions as the state vector. Following the notation at the beginning, this vector represents $ f (t, Y, U) $: mu = param(&#39;mu&#39;,10); nu = param(&#39;nu&#39;,1); %% F = @(t,Y,U,Params) [ Y(1)*Y(2) + U(2)*Params(1) ; ... -Y(2) + U(1)*norm(Params(2)) ] ; Using this dynamics vector, we construct an ‘ode’ class. dynamics = ode(F,Y,U,[mu nu]); The printed information above shows the default setting of this ‘ode’ class. In order to construct the dynamics we want, we need to customize its parameters. In this case we change the initial condition for the dynamics and the sampling timestep. The time discretization is generated as a uniform mesh from the timestep $ dt $. It will be used not only for the sampling of the state vector $ Y $ but also to represent the control vector $ U $ and cost $ J $ in ‘Pontryagin’ class. dynamics.InitialCondition = [0; -1]; dynamics.Nt = 10; Next we need to define the functional $ J $ we want to minimize. Following the form presented in [1], we define the expressions of $ Psi $ and $ L $ in symbolic form: Psi = @(T,Y) Y.&#39;*Y; L = @(t,Y,U) 0.005*(U.&#39;*U); We finally define the optimal control problem as a ‘Pontryagin’ class: iP = Pontryagin(dynamics,Psi,L); This class contains information we need to find the optimal control vector $ U $. It is worth mentioning that until now we defined the problem but not solved it yet. iP iP = Pontryagin with properties: Target: [] Functional: [1x1 PontryaginFunctional] Dynamics: [1x1 ode] Adjoint: [1x1 struct] Hamiltonian: [1x1 SymNumFun] ControlGradient: [1x1 SymNumFun] Hessian: [1x1 SymNumFun] AnalyticalControl: [1x1 SymNumFun] Solution: [] Constraints: [1x1 constraints] DyCon toolbox uses the gradient methods to optimize the cost functional. This calculates the gradient of $ J $ along $ U $ from the first order approximation of the Hamiltonian and adjoint state vector in the Pontryagin principle. To solve the problem using the default gradient method, we simply write: U0 = zeros(iP.Dynamics.Nt,iP.Dynamics.ControlDimension); GradientMethod(iP,U0); Solve with precision: We obtain: J(u) = 1.148222E-03 error = 2.000023E-03 With 3 iterations, In 0.083441 seconds This command generates ‘solution’ in the ‘Pontryagin’ class, which contains the optimal control vector ‘UOptimal’ and its information, such as the cost, precision and time of computations. iP.Solution ans = solution with properties: precision: 0.0020 iter: 3 time: 0.0834 Y0history: [] Yhistory: {[10x2 double] [10x2 double] [10x2 double]} ControlHistory: {[10x2 double] [10x2 double] [10x2 double]} Jhistory: [0.1200 0.0011 0.0011] Phistory: {[10x2 double] [10x2 double] [10x2 double]} dJhistory: {[10x2 double] [10x2 double] [10x2 double]} fhistory: [] dfhistory: [] Ehistory: [0 0.0020 0.0020] timeline: [] du: [] UOptimal: [10x2 double] JOptimal: 0.0011 This structure is independent of the solver, and we can see the results through visualization functions we want. One of the examples is ‘plot’ function which can be applied to ‘Pontryagin’ class. plot(iP)",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/ocp/T041_ClassicalGradient/",
    "relUrl": "/posts/04-PontryaginProblems/ocp/T041_ClassicalGradient/"
  },
  "20": {
    "id": "20",
    "title": "ConjugateGradient",
    "content": "DyCon toolbox adopts Pontryagin’s maximum principle to optimize the control function for each control problem. In this way we can solve problems of the form: subject to ‘Pontryagin’ class uses symbolic interface to define a control problem as in ‘ode’ class. ‘Pontryagin’ class contains ‘ode’ class, the final cost, and running cost. As ‘ode’ class contains $ f $, the final cost $ Psi $ and running cost $ L $ should be given by symbolic functions. Here we explain ‘Pontryagin’ class with a simple example: we want to minimize the objective function subject to The dynamics and cost functions are based on symbolic vectors $ Y $ and $ U $, which represent the state of the dynamics and control vector. Y = sym(&#39;y&#39;,[2 1]) Y = y1 y2 U = sym(&#39;u&#39;,[2 1]) U = u1 u2 The dynamics of $ Y $ should be given by a symbolic vector with the same dimensions as the state vector. Following the notation at the beginning, this vector represents $ f (t, Y, U) $: mu = param(&#39;mu&#39;,10); nu = param(&#39;nu&#39;,1); %% F = @(t,Y,U,Params) [ Y(1)*Y(2) + U(2)*Params(1) ; ... -Y(2) + U(1)*norm(Params(2)) ] ; Using this dynamics vector, we construct an ‘ode’ class. dynamics = ode(F,Y,U,[mu nu]); The printed information above shows the default setting of this ‘ode’ class. In order to construct the dynamics we want, we need to customize its parameters. In this case we change the initial condition for the dynamics and the sampling timestep. The time discretization is generated as a uniform mesh from the timestep $ dt $. It will be used not only for the sampling of the state vector $ Y $ but also to represent the control vector $ U $ and cost $ J $ in ‘Pontryagin’ class. dynamics.InitialCondition = [0; -1]; dynamics.Nt = 10; Next we need to define the functional $ J $ we want to minimize. Following the form presented in [1], we define the expressions of $ Psi $ and $ L $ in symbolic form: Psi = @(T,Y) Y.&#39;*Y; L = @(t,Y,U) 0.005*(U.&#39;*U); We finally define the optimal control problem as a ‘Pontryagin’ class: iP = Pontryagin(dynamics,Psi,L); This class contains information we need to find the optimal control vector $ U $. It is worth mentioning that until now we defined the problem but not solved it yet. iP iP = Pontryagin with properties: Target: [] Functional: [1x1 PontryaginFunctional] Dynamics: [1x1 ode] Adjoint: [1x1 struct] Hamiltonian: [1x1 SymNumFun] ControlGradient: [1x1 SymNumFun] Hessian: [1x1 SymNumFun] AnalyticalControl: [1x1 SymNumFun] Solution: [] Constraints: [1x1 constraints] DyCon toolbox uses the gradient methods to optimize the cost functional. This calculates the gradient of $ J $ along $ U $ from the first order approximation of the Hamiltonian and adjoint state vector in the Pontryagin principle. To solve the problem using the default gradient method, we simply write: U0 = zeros(iP.Dynamics.Nt,iP.Dynamics.ControlDimension); GradientMethod(iP,U0); Solve with precision: We obtain: J(u) = 1.148222E-03 error = 2.000023E-03 With 3 iterations, In 0.083441 seconds This command generates ‘solution’ in the ‘Pontryagin’ class, which contains the optimal control vector ‘UOptimal’ and its information, such as the cost, precision and time of computations. iP.Solution ans = solution with properties: precision: 0.0020 iter: 3 time: 0.0834 Y0history: [] Yhistory: {[10x2 double] [10x2 double] [10x2 double]} ControlHistory: {[10x2 double] [10x2 double] [10x2 double]} Jhistory: [0.1200 0.0011 0.0011] Phistory: {[10x2 double] [10x2 double] [10x2 double]} dJhistory: {[10x2 double] [10x2 double] [10x2 double]} fhistory: [] dfhistory: [] Ehistory: [0 0.0020 0.0020] timeline: [] du: [] UOptimal: [10x2 double] JOptimal: 0.0011 This structure is independent of the solver, and we can see the results through visualization functions we want. One of the examples is ‘plot’ function which can be applied to ‘Pontryagin’ class. plot(iP)",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/ocp/T041_ConjugateGradient/",
    "relUrl": "/posts/04-PontryaginProblems/ocp/T041_ConjugateGradient/"
  },
  "21": {
    "id": "21",
    "title": "IpoptSolver",
    "content": "DyCon toolbox adopts Pontryagin’s maximum principle to optimize the control function for each control problem. In this way we can solve problems of the form: subject to ‘Pontryagin’ class uses symbolic interface to define a control problem as in ‘ode’ class. ‘Pontryagin’ class contains ‘ode’ class, the final cost, and running cost. As ‘ode’ class contains $ f $, the final cost $ Psi $ and running cost $ L $ should be given by symbolic functions. Here we explain ‘Pontryagin’ class with a simple example: we want to minimize the objective function subject to The dynamics and cost functions are based on symbolic vectors $ Y $ and $ U $, which represent the state of the dynamics and control vector. Y = sym(&#39;y&#39;,[2 1]) Y = y1 y2 U = sym(&#39;u&#39;,[2 1]) U = u1 u2 The dynamics of $ Y $ should be given by a symbolic vector with the same dimensions as the state vector. Following the notation at the beginning, this vector represents $ f (t, Y, U) $: mu = param(&#39;mu&#39;,10); nu = param(&#39;nu&#39;,1); %% F = @(t,Y,U,Params) [ Y(1)*Y(2) + U(2)*Params(1) ; ... -Y(2) + U(1)*norm(Params(2)) ] ; Using this dynamics vector, we construct an ‘ode’ class. dynamics = ode(F,Y,U,[mu nu]); The printed information above shows the default setting of this ‘ode’ class. In order to construct the dynamics we want, we need to customize its parameters. In this case we change the initial condition for the dynamics and the sampling timestep. The time discretization is generated as a uniform mesh from the timestep $ dt $. It will be used not only for the sampling of the state vector $ Y $ but also to represent the control vector $ U $ and cost $ J $ in ‘Pontryagin’ class. dynamics.InitialCondition = [0; -1]; dynamics.Nt = 10; Next we need to define the functional $ J $ we want to minimize. Following the form presented in [1], we define the expressions of $ Psi $ and $ L $ in symbolic form: Psi = @(T,Y) Y.&#39;*Y; L = @(t,Y,U) 0.005*(U.&#39;*U); We finally define the optimal control problem as a ‘Pontryagin’ class: iP = Pontryagin(dynamics,Psi,L); This class contains information we need to find the optimal control vector $ U $. It is worth mentioning that until now we defined the problem but not solved it yet. iP iP = Pontryagin with properties: Target: [] Functional: [1x1 PontryaginFunctional] Dynamics: [1x1 ode] Adjoint: [1x1 struct] Hamiltonian: [1x1 SymNumFun] ControlGradient: [1x1 SymNumFun] Hessian: [1x1 SymNumFun] AnalyticalControl: [1x1 SymNumFun] Solution: [] Constraints: [1x1 constraints] DyCon toolbox uses the gradient methods to optimize the cost functional. This calculates the gradient of $ J $ along $ U $ from the first order approximation of the Hamiltonian and adjoint state vector in the Pontryagin principle. To solve the problem using the default gradient method, we simply write: U0 = zeros(iP.Dynamics.Nt,iP.Dynamics.ControlDimension); GradientMethod(iP,U0); Solve with precision: We obtain: J(u) = 1.148222E-03 error = 2.000023E-03 With 3 iterations, In 0.083441 seconds This command generates ‘solution’ in the ‘Pontryagin’ class, which contains the optimal control vector ‘UOptimal’ and its information, such as the cost, precision and time of computations. iP.Solution ans = solution with properties: precision: 0.0020 iter: 3 time: 0.0834 Y0history: [] Yhistory: {[10x2 double] [10x2 double] [10x2 double]} ControlHistory: {[10x2 double] [10x2 double] [10x2 double]} Jhistory: [0.1200 0.0011 0.0011] Phistory: {[10x2 double] [10x2 double] [10x2 double]} dJhistory: {[10x2 double] [10x2 double] [10x2 double]} fhistory: [] dfhistory: [] Ehistory: [0 0.0020 0.0020] timeline: [] du: [] UOptimal: [10x2 double] JOptimal: 0.0011 This structure is independent of the solver, and we can see the results through visualization functions we want. One of the examples is ‘plot’ function which can be applied to ‘Pontryagin’ class. plot(iP)",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/ocp/T041_IpoptSolver/",
    "relUrl": "/posts/04-PontryaginProblems/ocp/T041_IpoptSolver/"
  },
  "22": {
    "id": "22",
    "title": "Optimal control problem definition",
    "content": "Example We can create the optimal control problem % Get Symbolical variable Ys = iode.State.sym; Us = iode.Control.sym; ts = SX.sym(&#39;t&#39;); %% &lt;= Create a symbolical time % Set Target YT = zeros(2*M, 1); % PathCost = casadi.Function(&#39;L&#39; ,{ts,Ys,Us},{ (1/2)*(Us&#39;*Us) }); FinalCost = casadi.Function(&#39;Psi&#39;,{Ys} ,{ 1e7*((Ys-YT).&#39;*(Ys-YT)) }); % Create the optimal control iocp = ocp(iode,PathCost,FinalCost);",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/T04_OptimalControlProblem/",
    "relUrl": "/posts/04-PontryaginProblems/T04_OptimalControlProblem/"
  },
  "23": {
    "id": "23",
    "title": "ocp",
    "content": "The aim of this section is to give basis to solve analytically or numerically optimal control problems. In full generality, we consider a system governed by the dynamic: with $ Y in R^n$ is the state variable and $ U in R^m$ The control problems is: Given $T &gt; 0$, $ Y(0) = Y_0$ and $ Y(T) = Y_T$ does it exists $ U : [0,T] rightarrow R^m$ such that systems steers $ Y_0$ to $ Y_T$ in time $T$. For optimal control problem, we consider a cost function:",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/posts/04-PontryaginProblems/ocp/T04_ocp/",
    "relUrl": "/posts/04-PontryaginProblems/ocp/T04_ocp/"
  },
  "24": {
    "id": "24",
    "title": "Home",
    "content": "DYCON TOOLBOX MATLAB library for non-linear optimal control problems The DyCon Toolbox is a MATLAB library for analyzing both linear and non-linear optimal control problems. It uses CasADi-based automatic differentiation to compute all derivatives necessary for the optimization process. The DyCon Toolbox has a high-level syntax, which allows for an easy definition of the user’s control problem, and thus to its quick implementation. Moreover, the user may freely and easily tune the optimization algorithms in view of speeding-up the computation process. The DyCon Toolbox provides two different approaches for tackling a control problem: Direct method approach, which consists in discretizing both state and control. This reduces the original control problem to a nonlinear optimization problem (nonlinear programming). In this case, DyCon Toolbox provides a solution to the problem through optimization in IPOPT. Indirect method approach, which consists in numerically solving the adjoint problem backwards in time, and computing the functional derivative of the problem. Gradient descent-based methods can then be used to obtain the optimal control. Although direct methods are more common in the control community, when the problem is high dimensional, indirect methods are more efficient. The DyCon Toolbox unifies the definition of control problems so that they can be solved with the adequate method. FEATURES Sparse symbolic variables and automatic differentiation via CasADi Direct method using Ipopt Solver Indirect methods implemented (Pontryagin’s maximum principle) Compatible with MATLAB PDE Toolbox Easy to implement a new optimal control problems Many numerical schemes already implemented (Runge Kutta methods) A simple example The simultaneous optimal control problem is defined as: subject to: where: Numerical Implementation We first import the CasAdi library in order to create symbolic variables import casadi.* M = 50; nu = linspace(1,6,M); Then we create the matrices of linear dynamics. [A,B] = GenMatSim(nu); With these matrices we create the ode object % define the time span Nt = 500;T = 0.8; tspan = linspace(0,T,Nt); % create linear dynamic object iode = linearode(A,B,tspan); % set initial condition Y0 = ones(2, 1); iode.InitialCondition = repmat(Y0,M,1); then we create the optimal control problem % Get Symbolical variable Ys = iode.State.sym; Us = iode.Control.sym; ts = SX.sym(&#39;t&#39;); %% &lt;= Create a symbolical time % Set Target YT = zeros(2*M, 1); % PathCost = casadi.Function(&#39;L&#39; ,{ts,Ys,Us},{ (1/2)*(Us&#39;*Us) }); FinalCost = casadi.Function(&#39;Psi&#39;,{Ys} ,{ 1e7*((Ys-YT).&#39;*(Ys-YT)) }); % Create the optimal control iocp = ocp(iode,PathCost,FinalCost); We solve the Optimal Control Problem with an Ipopt solver U0 = ZerosControl(iode); % &lt;= Control initial guess [Uopt ,Yopt] = IpoptSolver(iocp,U0); This is Ipopt version 3.12.3, running with linear solver mumps. NOTE: Other linear solvers might be more efficient (see Ipopt documentation). Number of nonzeros in equality constraint Jacobian...: 199700 Number of nonzeros in inequality constraint Jacobian.: 0 Number of nonzeros in Lagrangian Hessian.............: 600 Total number of variables............................: 50500 variables with only lower bounds: 0 variables with lower and upper bounds: 0 variables with only upper bounds: 0 iter objective inf_pr inf_du lg(mu) ||d|| lg(rg) alpha_du alpha_pr ls 0 1.0000000e+09 1.12e-02 7.88e+00 -1.0 0.00e+00 - 0.00e+00 0.00e+00 0 1 4.0934345e+06 1.26e-13 5.63e-09 -1.0 1.66e+02 - 1.00e+00 1.00e+00f 1 Number of Iterations....: 1 ... EXIT: Optimal Solution Found. t_proc [s] t_wall [s] n_eval nlp_f 0.000381 0.00038 2 nlp_g 0.0042 0.0042 2 nlp_grad_f 0.00167 0.00167 3 nlp_hess_l 0.00331 0.00332 1 nlp_jac_g 0.026 0.026 3 solver 1.48 1.36 1 Elapsed time is 3.853462 seconds. We can compute the free solution Yfree = solve(iode,U0*0); Yfree = full(Yfree); Visualization fig = figure(); %% plotSimu(tspan,Yfree,Yopt,Uopt,M) Figure 1. The different colors represent the dynamic system under different parameters. It can be seen how the same control is obtained acting for all the dynamic systems is capable of driving the systems to the target.",
    "url": "https://deustotech.github.io/dycon-toolbox-documentation/",
    "relUrl": "/"
  }
  
}
