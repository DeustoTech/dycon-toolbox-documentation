<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DyCon Platform</title>
    <description>This MATLAB software is dedicated to the development and learning of control problems for applied mathematics.</description>
    <link>https://DeustoTech.github.io/dycon-platform-documentation/</link>
    <atom:link href="https://DeustoTech.github.io/dycon-platform-documentation/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 26 Oct 2018 16:38:24 +0200</pubDate>
    <lastBuildDate>Fri, 26 Oct 2018 16:38:24 +0200</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Riccati theory in LQ optimization with time-varying target</title>
        <description>In this short tutorial, we explain how to use Riccati’s theory to solve an LQ control problem with targets.

We consider the optimal control problem:



where:



In the above control problem, $A \in M_{n \times n}$, $B \in M_{n \times m}$, $C \in M_{r\times n}$ and $D\in M_{r\times n}$. The control $u:[0,T]\longrightarrow R^m$, while the state $x:[0,T]\longrightarrow R^n$. The control target is $q\in C^1([0,T];R^m)$ and the state target is $z\in C^1([0,T];R^n)$. $\beta\geq 0$ and $\gamma\geq 0$ are positive parameters.

By the Direct Methods in the Calculus of Variations and strict convexity, the above problem admits an unique optimal control $u^T$. The corresponding optimal state is denoted by $x^T$.

We compute the optimal pair (optimal control, optimal state) by using the well-known Riccati’s theory (see, for instance, [1, Lemma 2.6] and [2, section 4.3]).

For further details regarding the algorithm, we refer to RiccatiAlgorithm

Take

A=[2,-1;-1,2];
B=[1;0];
C=eye(2);
D=zeros(2,2);
beta=26;
gamma=0;
x0=[1.4;1.4];
q=@(t)0;
z=@(t)[sin(t);sin(t)];
T=10;
Nt=1000;


We solve an LQ problem with the above data.

[ uopt, x] = lqtarget( A,B,C,D,beta, gamma, q, z, x0,T,Nt );








Since the parameter $\beta$ is large enough and the control acts only on the first component of first equation


  
    the first component of the state is close to the target;
  
  
    the second component of the state is less close to the target;
  
  
    the control is far from its target.
  


The algorithm described in this guide can be employed to test the fulfillment of the turnpike property (see, for instance, 1 and 3). In agreement with the theory, the turnpike effect is evident if:


  
    the targets are constants;
  
  
    $(A,B)$ is controllable;
  
  
    $(A,C)$ is observable, $\beta&amp;gt;0$ and $\gamma=0$;
  
  
    the time horizon $T$ is large enough.
  


References

</description>
        <pubDate>Fri, 26 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0003-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0003-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Optimal control of a  graph evolving in discrete time</title>
        <description>In this tutorial we are going to show how to use MATLAB to control a discrete-time dynamical system that models the interactions between the nodes of a graph. The control policy will minimize a discrete linear quadratic regulator.

Let us consider a graph G that consists on $N$ nodes $x_i\in\mathbb{R}$, $i={1,2,…,N}$ that evolve in discrete time steps according to the following equation:



where $\gamma &amp;gt; 0$ is a coupling parameter.

We can simplify this equation by using the Perron matrix $P$ of the graph, this matrix is defined as $P = I - \gamma L$, where $L$ is the Laplacian of the graph and $I$ is the identity matrix. Let $x$ be $[x_1,…,x_N]^T$, the vector of states of the nodes. Moreover, we may add a control



to drive the states of the nodes to a desired state.



were $B$ and $C$ are two fixed matrices and $y\in\mathbb{R}^S$ are the observed states of $1\leq S\leq N$ nodes.

We aim to design a control policy ${u[k]}_{k=0,1,…}$ such that minimizes the following functional $J(x,u)$ while stabilizing the system.



where $Q$ and $R$ are semidefinite positive and definite positive matrices respectively. We can choose these two matrices in order to penalize aggressive or slow controls. To do so, we will use MATLAB’s control system toolbox.

Finally, we will add a reference term in the control so that we can drive the system into a desired state.

For instance, let us consider the coupling parameter

gamma = 0.1;


We define now a connected and bidirected graph G. Let E be the edges of the graph. We will define this set as a 2-column matrix and then we create the graph G.

E = [1, 2; 1, 3; 2, 4; 2, 5; 3, 4; 4, 5; 4, 6; 6, 7; 7, 8];
E = table(E,'VariableNames',{'EndNodes'});
G = graph(E);


This is our graph

plot(G, 'LineWidth', 2, 'EdgeColor', 'r', 'MarkerSize', 10)
title('Graph representation', 'FontSize', 16)




N is the size of the graph, that is to say, the number of nodes.

N = numnodes(G);


We compute the number of neighbours of each node

connectivities = degree(G);


We check whether the graph is connected or not, if not, we must choose a different graph.

if max(conncomp(G)) &amp;gt; 1
    print('Generate a new graph')
end


In this example the considered graph is connected.

We compute the Perron matrix of $G$.

P = eye(N) - gamma * laplacian(G);


We can see that the system tends to reach a consensus, that is to say, if no control is applied to the system, it evolves to a steady state in which all the nodes have the same state.

We define the initial state $x_0$

x_0 = [1, 5, 0, 4, 3, 1, 7, 3]';


The mean of $x_0$ is 3

mean(x_0)



ans =

     3




The states of the nodes will evolve to the mean of the states at the initial time. We let the system evolve for 150 iterations.

itmax = 150;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = P * x(:,k);
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Graph evolution without control','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




As stated before, we can see in this figure that the system naturally reaches consensus.

Recall that the system dynamics can be written as



for any $k =0,1,…$.

We want to find a control $u$ such that the system stabilizes to the zero state.

We proceed to define matrices B and C:

B = eye(N);
C = eye(N);
% We can check whether the system is controllable
if rank(ctrb(P,B)) &amp;lt; N
    print('it is not controllable!')
end
% In this case, it is controllable.


We choose the matrices $Q$ and $R$ by using Bryson and Ho’s criterium.

Q_diag = 1 / max(x_0.^2) * ones(1, N);
R_diag = 1 / 5^2 * ones(1, N);
Q = diag(Q_diag);
R = diag(R_diag);


We can use now the function dlqr (discrete linear quadratic regulator) to find the feedback control $u = -K_{f} x[k]$ that minimizes the functional $J(x,u)$.

[Kf, ~] = dlqr(P, B, Q, R);


Now we can stabilize the system by using the feedback control that we have just computed

itmax = 20;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k);
end


clf
hold on

for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Graph stabilization','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




We can see that the system is stabilized fast. One can tune the stabilization speed by choosing matrices $Q$ and $R$ in a smart way.

Now, we are about to add a reference term to the control to drive the system to a desired state. For instance, we can drive the system into the reference state

r = (1:N)';


We add a reference term to the control that is proportional to the reference r, $u[k] = -K_{f}x[k] + K_{r}r$. We can use linear algebra to compute the matrix $K_{r}$ in terms of the system matrices.

Kr = -(C * (P - B * Kf - eye(N))^(-1) * B)^(-1);


We drive the system to the reference state.

itmax = 20;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k) + B * Kr * r;
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Controlled graph','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




Assume now that we can control only the node 1 and we want to drive the node 8 to the reference state r = 1. Can we do it? Let’s see.

B = zeros(N, 1);
B(1) = 1;
C = zeros(1, N);
C(8) = 1;
if rank(ctrb(P,B)) &amp;lt; N
    print('it is not controllable!')
end


It is controllable.

Q_diag = 1 / max(x_0.^2) * ones(1, N);
R_diag = 1 / 5^2;
Q = diag(Q_diag);
R = diag(R_diag);
[Kf, ~] = dlqr(P, B, Q, R);
Kr = -(C * (P - B * Kf - eye(N))^(-1) * B)^(-1);
r = 1;
itmax = 200;
x = zeros(N, itmax + 1);
x(:,1) = x_0;
for k = 1:itmax
    x(:,k + 1) = (P - B * Kf) * x(:,k) + B * Kr * r;
end


clf
hold on
for k = 1:N
    plot(0:itmax,x(k,:),'LineWidth',2)
end
legend('Node 1','Node 2','Node 3','Node 4','Node 5','Node 6','Node 7','Node 8')
title('Driving node 8 to the state 1','FontSize',16)
xlabel('Iterations','FontSize',16)
ylabel('States of the nodes','FontSize',16)




As we can see, the node 8 is driven to the state 1 by achieving consensus in all the states of the graph.

References

</description>
        <pubDate>Fri, 26 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0001-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0001-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>LQR control of a fractional reaction diffusion equation</title>
        <description>We design a LQR controller for stabilyzing the fractional reaction diffusion



where $\delta&amp;gt;0$ is a given constant, $\omega = (a,b)\subset(-L,L)$ and $(-d_x^2)^s$, $s\in(0,1)$ denotes the one-dimensional fractional Laplacian defined as



with $c(s)$ an explicit normalization constant.

When considering this equation without the action of the the control $u$, we know that, depending on the value of $\delta$, the corresponding dynamics may become unstable. This is due to the fact that the eignenvalues of the associated elliptic problem are given by $\mu_k=c-\lambda_k$ ($\lambda_k$ being the eigenvalues of the fractional Laplacian on $(-L,L)$ with zero Dirichlet boundary conditions), and they are positive if $c&amp;gt;\lambda_1$ (since, in addition, we know that $\lambda_1&amp;lt;\lambda_k$ for all $K$). We are then intersted in designing a LQR control which is able to stabilyze this solution and prevent its blow-up.

The computation of the LQR control is carried out by means of the following procedure:

STEP 1. Discretization of the equation

We start by discretizing our original system on a uniform mesh ${x_i}_{i=1}^N$, thus obtaining a N-dimensional system of the type



where:


  
    with some abuse of notation, we denoted $y\in\mathbb{R}^N$ as the   $N$-dimensional vector whose entries $y_i=y(x_i)$, $i=1,\ldots,N$ are   the evaluation of the function $y$ on the points of the mesh;
  
  
    the matrix $A$ is a discretization of the operator $-(-d_x^2)^s + I$,   $I$ denoting the ideintity;
  
  
    the matrix $B$ defines the action of the control.
  


The computation of the matrix requires the discretization of the fractional Laplacian $(-d_x^2)^s$. This which is done by employing the function “fl_rigidity”, which implements a finite elements method on a uniform mesh discretizing the space interval $(-L,L)$ (complete details on this method may be found in [1]).

The function “fl_rigidity” works by requiring 3 input parameters:


  
    s: the order of the fractional Laplacian, which can be any real value      in the interval $(0,1)$;
  
  
    L: the extrema of the space interval $(-L,L)$;
  
  
    N: the number of discretization points in the mesh employed.
  


The outputs are:


  
    x: the vector containing the mesh;
  
  
    A: the matrix discretizing the fractional Laplacian.
  


The matrix B, instead, is constructed by employing the function “construction_matrix_B”, which takes in input


  
    the vector $x$ containing the mesh;
  
  
    the number of discretization points $N$;
  
  
    the characteristic function of the sub-interval $\omega$.
  


STEP 2. Definition of the cost functional and computation of the control

Once we have the semi-discretization of our original problem, the control we are looking for is computed by minimizing the following cost functional



where $Q\geq 0$ and $R&amp;gt;0$ are given matrices. Moreover, we know that this control is given in a feedback form by $u^*=-R^{-1}B^TPy$, where $P$ is the solution of the algebraic Riccati equation



Implementation

clear all
clc


We start by defining the parameter $s\in(0,1)$ (order of the fractional Laplacian), the size of the interval $(-L,L)$, the constant $\delta&amp;gt; \lambda_1$ and the number $N$ of discretizaiton points in our mesh.

s = 0.8;
L = 1;
d = (0.5*pi)^(2*s)+0.1;
N = 100;


and we compute the corresponding approximation of the fractional Laplacian

[x,FL] = fl_rigidity(s,L,N);


We then use it for building the matrice $A$ describing the dynamics

D = d*eye(N);
A = -FL+D;


Secondly, we use the function “construction_matrix_B” for computing the control operator $B$ on the interval $\omega=(-0.3,0.5)$

matrix_B =  @(x) interval(x,-0.3,0.5);
B = construction_matrix_B(x,N,matrix_B);


Out of the matrices $A$ and $B$, we solve the algebraic Riccati equation by employing the specific function from the control systems toolbox of Matlab. For simplicity, we choose both $R$ and $Q$ as the identity, but other choices are possible in order to improve the efficiency of the method.

R = eye(N);
Q = eye(N);
[P,cleig,K,report] = care(A,B,eye(N));


The output matrix $K=-R^{-1}B^TP$ is used for defining the action of the control and include it in our system

f_ctr = @(x) -K*x;
eq_ctr = @(t,x) A*x + B*f_ctr(x);


Finally, we choose an initial datum

y0 = cos(pi*x)';


and we solve our equation with and without control employing the “ode45” function of Matlab. For the equation without control we choose a relatively short time horizon, since we know that the unstable dynamics will rapidly diverge. For the equation with control, instead, we choose a longer time horizon in order to have enough time for stabilyzing the system.

T1 = 4;
T2 = 25;
Nt = 40;
tspan1 = linspace(0,T1,Nt);
tspan2 = linspace(0,T2,Nt);
eq_free = @(t,x) A*x;
[time1, sol_free] = ode45(eq_free,tspan1,y0);
[time2, sol_ctr] = ode45(eq_ctr,tspan2,y0);


We then plot our results and compare them. Firstly, the free dynamics.

surf(x,time1,sol_free)
colormap jet
msol_free = floor(min(min(sol_free)));
Msol_free = round(max(max(sol_free)));
xticks([-L L])
yticks([0 T1])
zticks([msol_free Msol_free])
view(135,25)
title('Free unstable dynamics')




We clearly see the growth of the solution, already in the short time horizon [0,4]. When introducing the LQR control, instead, the problem is corrected and the equation is stabilyzed in time $T_2$

surf(x,time2,sol_ctr)
colormap jet
msol_ctr = floor(min(min(sol_ctr)));
Msol_ctr = round(max(max(sol_ctr)));
xticks([-L,L])
yticks([0 T2])
zticks([msol_ctr Msol_ctr])
view(135,25)
title('Controlled dynamics')




References

[1] U. Biccari and V. Hernandez-Santamaria, “Controllability of a one-dimensional fracitonal heat equation: theoretical and nuerical aspects”, IMA J. Math. Control I. (2018).

</description>
        <pubDate>Wed, 24 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0004-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp99/P0004-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP99</category>
        
      </item>
    
      <item>
        <title>Synchronized Oscillators</title>
        <description>What’s a consensus problem?

We consider a population of N coupled-phase oscillators, $\theta_i(t)$, $i=1,\ldots,N$ and we want to compute a control such that in time $T$ we reach the state $\theta_i(T)=\ldots =\theta_N(T)=:\bar{\theta}$ in which all the oscillators are sincronized.

The mathematical model

The dynamics of the oscillators is described by the Kuramoto model





The model is non-linear, then, we apply a standard linearization process around the steady state $\bar{\theta}$ obtaining



By classical techniques, the control is obtained by minimizing the following cost functional, subject to the linearized Kuramoto model, for each node



in which


  
    the first term measures the distance between the rest of nodes and the target.
  
  
    the second term is a penalization one introduced in order to   avoid using control with a too large size.
  


In fact, through the above minimization procedure, we find the control $b = (b_1,\ldots,b_N)$ which has minimum norm among all the controls capable to steer the system to the equilibrium dynamics.

How do you usually solve this type of problem?

The usual technique for solving minimizing problems based on quadratic functionals is the Gradient Descent Method, which is based on the following iterative algorithm



This technique is tipycally chosen because: - It is (relatively) easy to implement. - It is not very memory demanding.

What we propose?

As the functional J(b_i) depend on all nodes $\Theta_j$, the gradient $\nabla J(b_i)$ too. Therefore, in each iteration of the Gradient Descent algorithm we shall consider all nodes in the network. Then, when the number of nodes is large, the complexity if substantial per iteration. To avoid evaluate the full gradient, we propose to approach the problem by means of the Stochastic Descent Gradient method which only uses a small portion of data.

Matrix $A$ of the linearized Kuramoto model

N = 7;
A = (1/N)*ones(N,N);
for i = 1:N
    A(i,i) = -1;
end
A



A =

   -1.0000    0.1429    0.1429    0.1429    0.1429    0.1429    0.1429
    0.1429   -1.0000    0.1429    0.1429    0.1429    0.1429    0.1429
    0.1429    0.1429   -1.0000    0.1429    0.1429    0.1429    0.1429
    0.1429    0.1429    0.1429   -1.0000    0.1429    0.1429    0.1429
    0.1429    0.1429    0.1429    0.1429   -1.0000    0.1429    0.1429
    0.1429    0.1429    0.1429    0.1429    0.1429   -1.0000    0.1429
    0.1429    0.1429    0.1429    0.1429    0.1429    0.1429   -1.0000




Initial condition: 

mu = 4;sigma = 10;
theta0 = normrnd(mu,sigma,N,1)



theta0 =

   20.3206
  -11.3219
   -9.3685
  -10.7385
    3.5834
   -2.1551
   17.1415




Now, choose initial control,

t0 = 0;T = 1;dt = 0.1;
tspan = t0:dt:T;
u0 = zeros(length(tspan),N);


We can solve with the StochasticGradient function.

Results_Stochastic =  StochasticGradient(A,theta0,tspan,u0);


And see the convergence

fig1 = JPlotConvergence(Results_Stochastic,'Convergence of Stochastic Method');




We can see the result obtained

fig2 = LastThetaPlot(Results_Stochastic);




Comparison Clasical vs Stochastic

In this example, we show that stochastic method is faster than the classical descent in a small network.

Results_Classical = {};Results_Stochastic = {};
%
maxN = 500; % &amp;lt;=== Maximal number of oscillator allowed in the model
iter = 0;
for N = 1:100:maxN
    % We solve the problem for each N
    iter = iter + 1;
    % Definition of the linearized Kuramoto problem
    A = (1/N)*ones(N,N);
    for i = 1:N
        A(i,i) = -1;
    end
    % Initial state
    mu = 4;sigma = 5;
    theta0 = normrnd(mu,sigma,N,1);
    % Initial control
    t0 = 0;T = 1;dt = 0.1;
    tspan = t0:dt:T;
    u0 = zeros(length(tspan),N);

    % Classical Gradient Method
    Results_Classical{iter}  =  ClassicalGradient(A,theta0,tspan,u0);
    % Stochastic Gradient Method
    Results_Stochastic{iter} =  StochasticGradient(A,theta0,tspan,u0);
end


We can graphically see the following result. If the number of nodes increase we can see better the efectiveness of the stochastic gradient descent method with respect to the classical.

% For the next step it is necessary to convert the cells into arrays
Results_Classical  = [Results_Classical{:}];
Results_Stochastic = [Results_Stochastic{:}];
%
fig2 = figure; ax  = axes;
ax.FontSize = 17;
ax.XLabel.String = 'Number of Oscillators'; ax.YLabel.String = 'time(s)';
ax.XGrid = 'on'; ax.YGrid = 'on';
%
line([Results_Stochastic.N],[Results_Stochastic.t],'Parent',ax,'Color','red','Marker','s')
line([Results_Classical.N],[Results_Classical.t],'Parent',ax,'Color','blue','Marker','s')
legend({'Stochastic Gradient','Classical Gradient'})




Altough in this example we are dealing with a small network, we have shown that stochastic method is faster than the classical descent. If the number of nodes increase we can see better the efectiveness of the stochastic gradient descent method with respect to the classical. 

</description>
        <pubDate>Fri, 19 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp01/P0004-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp01/P0004-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP01</category>
        
      </item>
    
      <item>
        <title>Gradient Descent in semilinear control</title>
        <description>We solve



where:



The fucntional $J_T$ is made of two addenda. The first one penalizes the control, while the second one is a tracking term penalizing the distance between the state and the target. Our goal is to keep the state near the target for all times, by a cheap control. As $\beta$ increases, the distance between the optimal state and the target decreases.

For time horizon $T$ large, one can check the emergence of the Turnpike property (see 1). For further details about the problem, see e.g. 1, 2 or 3.

We employ a Gradient Descent Method.

STEP 1. We define the parameters for the algorithm.

Number of points in the space partition.

%We count the boundary
Nx=50;


Number of time steps

Nt=200;


WARNING: We have to fulfill Courant-Friedrichs-Levy condition:



Time horizon

T=2;


Penalization parameter for the state.

beta=1000;


Initial datum for the state equation.

init=zeros(Nx,1);


Target for the state.

zdiscr=ones(Nx,1);


Maximum number of iterations

Nmax = 100;


Stepsize for the Gradient Descent algorithm. appearing in the definition of the new iterate u = uold - delta*dJuold.

delta = 0.1;


Tolerance

tol = 1e-1;


STEP 2. We initialize the algorithm.

Control at time iter

u = zeros(Nt,floor(Nx/2));


Control at time iter-1

uold = u;


We compute the state yold corresponding to the control uold. The multiplication by the characteristic function $\chi_{(0,0.5)}$ is included in the definition of “source”.

source=zeros(Nt,Nx);
for k=1:Nt
    for i=1:floor(Nx/2)
        source(k,i)=u(k,i);
    end
end

[ y ] = heat_semilinear( @(x) x.^3, T, init, source );


We compute the adjoint state corresponding to control uiter. We define the matrix defining the discretized version of the source: $\beta(y(t,x)-z(x))$.

source=zeros(Nt,Nx);
for k=1:Nt
    for i=1:Nx
        source(k,i)=beta*(y(k,i)-zdiscr(i,1));
    end
end

[ p ] = adjoint_heat_semilinear( y, T, source );

prestr=p(:,1:floor(Nx/2));
prestrold=prestr;


% Initial error
error = 10;
% Iteration counter
iter = 0;


STEP 3. We set up a while loop for the Gradient Descent method.

while (error &amp;gt; tol &amp;amp;amp;&amp;amp;amp; iter &amp;lt; Nmax)
    % Update iteration counter
    iter = iter + 1;

    % Gradient computed at u_{old}
    dJuold = uold+prestrold;
    % Update control
    u = uold - delta*dJuold;

    %We compute the state y_{iter} corresponding to the control uiter

    %In the definition of &quot;source&quot;
    %it is included the multiplication by
    %the characteristic function \chi_{(0,0.5)}.
    source=zeros(Nt,Nx);
    for k=1:Nt
        for i=1:floor(Nx/2)
            source(k,i)=u(k,i);
        end
    end

    [ y ] = heat_semilinear( @(x) x.^3, T, init, source );

    %We compute the adjoint state
    %corresponding to control uiter.

    %We define the matrix defining
    %the discretized version of
    %the source:
    %\beta(y(t,x)-z(x)).

    source=zeros(Nt,Nx);
    for k=1:Nt
        for i=1:Nx
            source(k,i)=beta*(y(k,i)-zdiscr(i,1));
        end
    end

    [ p ] = adjoint_heat_semilinear( y, T, source );

    prestr=p(:,1:floor(Nx/2));
    prestrold=prestr;

    %old control
    uold=u;

    % Control update norm
    dJuold2 = sum(sum(dJuold.^2))*(T/(Nt-1))*(1/(Nx-1));
    u2 = sum(sum(u.^2))*(T/(Nt-1))*(1/(Nx-1));

    if (u2 == 0)
        error=sqrt(dJuold2);
    else
        error=sqrt(dJuold2/u2);
    end

    %we compute the state term of the fucntional.
    stateterm=0;
    for k=1:Nt
        stateterm=stateterm+sum((transpose(y(k,:))-zdiscr).^2)*(1/(Nx-1))*(T/(Nt-1));
    end
    Ju=(0.5)*u2+(beta/2)*stateterm;

    fprintf(&quot;Iteration %i - Error %g - Cost %g\n&quot;, iter, error, Ju);

end


Iteration 1 - Error 10 - Cost 503.646
Iteration 2 - Error 2.69873 - Cost 429.651
Iteration 3 - Error 1.0966 - Cost 414.035
Iteration 4 - Error 0.552452 - Cost 409.793
Iteration 5 - Error 0.320747 - Cost 408.451
Iteration 6 - Error 0.21037 - Cost 407.986
Iteration 7 - Error 0.152608 - Cost 407.827
Iteration 8 - Error 0.118849 - Cost 407.792
Iteration 9 - Error 0.0967289 - Cost 407.812



STEP 4. Optimal control and optimal state.

%approximate optimal control.
uopt=u;
%approximate optimal state.
yopt=y;


STEP 5. We plot optimal control and optimal state.

Optimal control.

figure(1)
clf(1);
timecontrol=linspace(0,T,Nt);
spacecontrol=linspace(0,1,floor(Nx/2));
[TIMECONTROL,SPACECONTROL]=meshgrid(timecontrol,spacecontrol);
surf(TIMECONTROL,SPACECONTROL,transpose(uopt),'EdgeColor','none');
colormap jet;
%title('optimal control');
xlabel('t [time]','FontSize',20);
ylabel('x [space]','FontSize',20);
zlabel('u [control]','FontSize',20);
xt=get(gca,'XTick');
set(gca,'FontSize',20);




Optimal state.

figure(2);
clf(2);
time=linspace(0,T,Nt);
space=linspace(0,1,Nx);
[TIME,SPACE]=meshgrid(time,space);
surf(TIME,SPACE,transpose(yopt),'EdgeColor','none');
colormap jet;
%title('optimal state');
xlabel('t [time]','FontSize',20);
ylabel('x [space]','FontSize',20);
zlabel('y [state]','FontSize',20);
xt=get(gca,'XTick');
set(gca,'FontSize',20);




References


  
    
      Porretta, Alessio and Zuazua, Enrique, Remarks on long time versus steady state optimal control, Mathematical Paradigms of Climate Science, Springer, 2016, pp. 67–89 &amp;#8617; &amp;#8617;2
    
    
      Casas, Eduardo and Mateos, Mariano, Optimal control of partial differential equations,    Computational mathematics, numerical analysis and applications,    Springer, Cham, 2017, pp. 3–5. &amp;#8617;
    
    
      Troltzsch, Fredi, Optimal control of partial differential equations, Graduate studies in mathematics, American Mathematical Society, 2010. &amp;#8617;
    
  

</description>
        <pubDate>Thu, 18 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp02/P0001-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp02/P0001-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP02</category>
        
      </item>
    
      <item>
        <title>WKB expansion for a fractional Schrödinger equation with applications to controllability</title>
        <description>In recent years, the study of fractional integro-differential equations applied to physics and other areas has faced an extensive growth. In this framework, in the early 2000 Laskin started considering extensions of the classical quantum mechanics theory, based on the idea of replacing the classical Brownian trajectories in Feynman path integrals by Levy flights, which are generated by fractional Laplacians (). This gave birth to Fractional Quantum Mechanics (FQM), which is the theory of quantum mechanics based on the fractional Schrödinger equation (FSE), instead than on the classical integer one.
Later on, these kind of models found applications in several branches of physics, such as the study of condensed-matter realizations of Lévy cristals (), lasers implementation (), acoustic wave equations (), gravity waves (), geophysics ().
The prototypical example of a fractional Schrödinger equation is given by the following one-dimensional non-local partial differential equation $$\begin{aligned}
\label{main_eq}
    {\mathcal{P} }_s u:= \left[i\partial_t + {(-d_x^{\,2})^{s} }\right]u = 0, &amp;amp;\;\;  (x,t)\in{\mathbb{R} }\times(0,+\infty), \end{aligned}$$ in which ( − dx 2)s is the fractional Laplacian, defined for all s ∈ (0, 1) and for any function f sufficiently smooth as the following singular integral $$\begin{aligned}
{(-d_x^{\,2})^{s}f}(x):={c_{1,s} }\; P.V. \int_{ {\mathbb{R} }}\frac{f(x)-f(y)}{ {|x-y|^{1+2s} }}\,dy,\end{aligned}$$ with c1, s a normalization constant given by $$\begin{aligned}
    {c_{1,s} }:= \left(\int_{ {\mathbb{R} }} \frac{1-\cos(z)}{|z|^{1+2s} }\,dz\right)^{-1} = \frac{s2^{2s}\Gamma\left(s+\frac 12\right)}{\sqrt{\pi}\Gamma(1-s)},\end{aligned}$$ where Γ is the usual Gamma function.
In , we developed a study of the propagation properties of the solutions of , based on a WKB analysis of the equation starting from a highly oscillatory initial datum in the form $$\begin{aligned}
\label{in_dat}
    u(x,0) = {u_{\textrm{\small in} }}(x) e^{i\frac{\xi_0}{\varepsilon} x}:=u_0(x),\;\;\; \xi_0\in{\mathbb{R} }.\end{aligned}$$
Here, the parameter ε represents the fast space and time scale introduced in the equation, as well as the typical wavelength of oscillations of the initial datum.
Asymptotic analysis for wave-like equations through geometric optics (also known as the Wentzel-Kramers-Brillouin (WKB) method or ray-tracing, ) is nowadays a classical tool that has been developed in several directions. An incomplete biography on the topic includes . It is by now well-known that wave-type equations, in a local framework, have solutions that are localized near curves (t, x(t)) in space-time, also called rays. These curves are, in the interior of the domain of definition of the equation, solutions of a Hamiltonian system of ordinary differential equations which involves the coefficients of the operator. When one of these trajectories hits the boundary of the domain it is reflected according to the classical laws of optics.
In the case of equation , since 𝒫s = i∂t + ( − dx 2)s is a pseudo-differential operator with principal symbol ps(x, t, ξ, τ)=τ − |ξ|2s, the Hamiltonian system is given by $$\begin{aligned}
    \begin{cases}
        \dot{x}(\sigma) = \partial_\xi p_s = \pm 2s|\xi(\sigma)|^{2s-1}, &amp;amp; x(0)=x_0
        \\
        \dot{t}(\sigma) = \partial_\tau p_s = 1, &amp;amp; t(0)=0
        \\
        \dot{\xi}(\sigma) = -\partial_x p_s = 0, &amp;amp; \xi(0)=\xi_0
        \\
        \dot{\tau}(\sigma) = -\partial_t p_s =0, &amp;amp; \tau(0)=|\xi_0|^{2s}.
    \end{cases}\end{aligned}$$
In addition, this system can be easily solved explicitly, and we obtain the following expressions for the bicharacteristics $$\begin{aligned}
    \begin{cases}
        x(\sigma) = x_0 \pm 2s|\xi_0|^{2s-1}\sigma
        \\
        t(\sigma) = \sigma 
        \\
        \xi(\sigma) = \xi_0
        \\
        \tau(\sigma) = |\xi_0|^{2s}.
    \end{cases}\end{aligned}$$
In particular, the rays of 𝒫s are given by the curves (t, x0 ± 2s|ξ0|2s − 1t)∈(0, +∞) × ℝ. Notice that, as one expects since the operator has constant coefficients, these rays are straight lines.
The approach that we use for building localized solutions is quite standard. In particular, we look for quasi-solutions to introducing the ansatz $$\begin{aligned}
\label{ansatz}
    {u^{\,\varepsilon} }(x,t) = \varepsilon^s e^{i\left[\xi_0\varepsilon^{-1}x\,+\,|\xi_0|^{2s}\varepsilon^{-2s}t\right]}\sum_{j\geq 0}\varepsilon^{\frac{s}{2}j}a_j\left(x,\varepsilon^{\frac{3}{2}s}t\right),\end{aligned}$$ where the normalization constant εs is chosen asking that the function u ε has Hs(ℝ)-norm of the order $\mathcal O(1)$. The identification of the aj-s is then carried out imposing $$\begin{aligned}
{\mathcal{P} }_s{u^{\,\varepsilon} } = O(\varepsilon^{\infty}), \end{aligned}$$ thus obtaining a series of PDEs in which it is possible to clearly separate the leading order terms, with respect to ε, from several remainders which will vanish as ε → 0. This generates a cascade system for the functions aj, which can then be determined as the solution of certain given Partial Differential Equations. In our case, the cascade system is the following one $$\begin{aligned}
\label{cascade_system}
    \begin{cases}
        i\partial_\tau a_0 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2} } a_0 = 0  
        \\
        i\partial_\tau a_1 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2} } a_1 + \mathcal{C}_{s} \mathcal{D}^{s} a_0 = 0  
        \\
        i\partial_\tau a_2 + \mathcal{C}_{\frac s2} \mathcal{D}^{\frac{s}{2} } a_2 + \mathcal{C}_{s} \mathcal{D}^{s} a_1 + \mathcal{C}_{\frac{3s}{2} } \mathcal{D}^{\frac{3s}{2} } a_0(\theta,\tau) = 0, &amp;amp; \displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q
        \\
        i\partial_\tau a_j + \mathcal{C}_{\frac s2}\mathcal{D}^{\frac{s}{2} }a_j + \mathcal{C}_{s} \mathcal{D}^{s}a_{j-1} +  \mathcal{C}_{\frac{3s}{2} } \mathcal{D}^{\frac{3s}{2} }a_{j-2}(\theta,\tau) + {(-d_x^{\,2})^{s}a_{j-3} }, &amp;amp; j\geq 3
        \\
        &amp;amp;\displaystyle x\leq\theta\leq x+\frac{\varepsilon}{\xi_0}q.  
    \end{cases}\end{aligned}$$ with $\tau:=\varepsilon^{\frac 32 s}t$ and where 𝒟 β denotes the following fractional derivative of order β $$\begin{aligned}
    \mathcal{D}^{\beta} f(x):= \frac{1}{\Gamma(1-\beta)}\int_{-\infty}^x \frac{f'(y)}{(x-y)^{\beta} }\,dy.\end{aligned}$$
Moreover, is uniquely solvable with initial conditions imposed at τ = 0 and this, of course, allows to identify the expressions of the functions aj. See  for more details.
To the best of our knowledge, a WKB approach has not yet been fully developed in a non-local setting, and our work represents a first step in this direction, providing a complete procedure for obtaining a WKB expansion of equation .
Our study is motivated by control problems. Indeed, it is by now well-known that geometric optics constructions for wave-like equations can be used for deriving controllability properties. These properties are usually formulated by means of an observability inequality, in which the total energy of the solutions is uniformly estimated by a partial measurement (typically, the portion of energy localized in a subset of the domain or of its boundary). In this framework, the existence of localized solutions gives sharp necessary conditions for the observability property to hold. In fact, as it was remarked by Ralston in , in order to observe these solutions the observation set must intersect every ray. If this were not the case, one could construct a quasi solution along a ray that would not hit the observation set and which, being negligible outside an arbitrarily small neighborhood of the ray, could not be observed. This is the so-called Geometric Control Condition (GCC), which has been proved to be almost sufficient by Bardos, Lebeau and Rauch in , and necessary by Burq and Gérard in .
In the particular case under analysis, we are able to show that given a ray (t, x(t)) it is possible to construct quasi-solutions of the fractional Schrdinger equation such that the amount of their energy outside a ball of radius $\varepsilon^{\frac 14}$ centered at x(t) is of the order of $\varepsilon^{\frac 14}$. In more detail, we can show that if ${u_{\textrm{\small in} }}\in L^2({\mathbb{R} })$ and u ε is constructed employing the expansion , then

The functions u ε are approximate solutions to : on the one hand, we have that the function z ε a time t = 0 is close, in the L2-norm, to any initial datum in the form $$\begin{aligned}
        { {\left\|u_0(x)-{u^{\,\varepsilon} }(x,0)\right\|}_{L^2({\mathbb{R} })} } = \mathcal{O}(\varepsilon^{\frac{1}{2} }),\;\;\;\forall\varepsilon&amp;gt;0.
    \end{aligned}$$ On the other hand, the same remains true also for any other time t &amp;gt; 0. $$\begin{aligned}
        { {\left\|u(x,t)-{u^{\,\varepsilon} }(x,t)\right\|}_{L^2({\mathbb{R} })} } = \mathcal{O}(\varepsilon^{\frac 12}),\;\;\;\forall\varepsilon&amp;gt;0.
    \end{aligned}$$ Hence, the functions z ε are really approximating the real solution of in a L2-setting.
The initial energy of z ε, i.e. the energy at t = 0, is essentially bounded, up to some small reminder which vanishes as ε → 0+: $$\begin{aligned}
        { {\left\|{u^{\,\varepsilon} }(x,0)\right\|}_{H^s({\mathbb{R} })} }^2 \approx 1.
    \end{aligned}$$ Also in this case, as a consequence of the energy conservation property, this same fact remains true for all times t &amp;gt; 0.
The amount of energy away from a given ray (t, x(t)) of size $\varepsilon^{\frac 14}$ is of the same order $\varepsilon^{\frac 14}$: $$\begin{aligned}
        \int_{|x-x(t)|&amp;gt;\varepsilon^{\frac 14} } \left|{(-d_x^{\,2})^{\frac s2}{u^{\,\varepsilon} }}(x,t)\right|^2\,dx = \mathcal O(\varepsilon^{\frac 14}).
    \end{aligned}$$ In other words, the energy which is not concentrated along x(t) is negligible with respect to the total amount. This third property is possibly the most important one, since it justify the possibility to analyze the propagation of the solutions of simply in terms of the propagation of the rays.

In order to study propagation properties of the solutions of our equation in terms of the propagation of the rays, a very important quantity that we shall consider is the so-called group velocity, which can be easily computed as $$\begin{aligned}
    v=\left|\frac xt\right| = 2s\varepsilon^{1-2s}|\xi_0|^{2s-1}.\end{aligned}$$
From the above formula we immediately see that, for s = 1/2 we have v = 1, i.e. the velocity is constant and independent of the frequency ξ0. For s ∈ (0, 1/2), instead, we have that 1 − 2s &amp;gt; 0. Hence, taking ε &amp;lt; 1, we easily get $$\begin{aligned}
    v&amp;lt;|\xi_0|^{2s-1}.\end{aligned}$$ Finally, for s ∈ (1/2, 1) the situation is the opposite. We have 1 − 2s &amp;lt; 0 and, for ε &amp;lt; 1, $$\begin{aligned}
    v&amp;gt;|\xi_0|^{2s-1}.\end{aligned}$$
Hence, we can conclude that for s &amp;gt; 1/2 the group velocity increases with the frequency and that the high frequency solutions are traveling faster and faster. On the other hand, for s &amp;lt; 1/2, the group velocity decreases with the frequency the high frequency solutions are traveling and slower and slower. This behavior has then consequences from the point of view of observation properties for the solutions and, in particular, it confirms the already known results presented in .

</description>
        <pubDate>Mon, 01 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/posts/WBK-Expasion</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/posts/WBK-Expasion</guid>
        
        
        <category>Posts</category>
        
      </item>
    
      <item>
        <title>Control of PDEs involving non-local terms</title>
        <description>Why non-local?

Relevant models in Continuum Mechanics, Mathematical Physics and Biology are of non-local nature:

  Boltzmann equations in gas dynamics;
  Navier-Stokes equations in Fluid Mechanics;
  Keller-Segel model for Chemotaxis.


Moreover, these models are applied for the description of several complex phenomena for which a local approach is inappropriate or limiting.

  Peierls-Nabarro equation in elasticity 1
  Image processing algorithms 2
  Anomalous diffusion models 3
  Finance: description of the pricing of American options 4.


In this setting, classical PDE theory fails because of non-locality. Yet many of the existing techniques can be tuned and adapted, although this is often a delicate matter.

Fractional time derivatives

We analyze the problem of controllability of fractional (in time) Partial Differential Equations. In contrast with the classical PDE control theory, when driving these systems to rest, one is required not only to control the value of the state at the final time but also the memory accumulated by the long-tail effects that the fractional derivative introduces.
As a consequence, the notion of null controllability to equilibrium needs to take into account both the state and the memory term.

In particular, in (5) we consider the full controllability problem for the system



with $A$ and $B$ two linear unbound operators and where $\partial_{t,0+}^{\alpha}$ is a classical Caputo derivative. We show that, due to the memory effects controllability cannot be achieved in finite time.

Fractional Schrödinger and wave equations

In 6, we analyse evolution problems involving the fractional Laplace operator $(-\Delta)^s$, $s\in(0,1)$, on a bounded $C^{1,1}$ domain $\Omega\subset\mathbb{R}^N$. In particular we consider the fractional Schrödinger equation



and the fractional wave equation



Our main goal is to study the controllability of this kind of phenomena.


  Fractional Schrödinger equation: we assume Dirichlet homogeneous boundary conditions and we prove null controllability provided $s\geq 1/2$ and that the control is active on a neighborhood $\omega$ of a subset of the boundary fulfilling the classical multiplier conditions. Moreover, in the limit case $s=1/2$, controllability holds only if the control time $T$ is large enough.
  Fractional wave equation: we obtain analogous controllability properties, as a direct consequence of the results for the Schrödinger equation.


These mentioned controllability properties may be studied also through the employment of microlocal analysis techniques. In this framework, in 7 we present a WKB expansion for the fractional Schrödinger equaiton in one space dimension, which allows to show that the solutions of the model propagate following the rays of geometric optics and that their controllability properties may be reinterpreted in terms of the velocity of propagation of this mentioned rays.

Viscoelasticity

Viscoelastic materials are those for which the behaviour combines liquid-like and solid-like characteristic 8.







In 9, we consider the following model of viscoelasticity, given by a wave equation with both a viscous Kelvin-Voigt and frictional damping



in which we incorporate an internal control $h$ with a moving support. Our analysis is based on the fact that the above equation can be rewritten as a system coupling a parabolic equation with an ODE. The presence of this ODE, in the case of a fixed  support of the control, is responsible for the lack of controllability of the system, due to the absence of propagation in the space-like direction. Therefore, we prove the null controllability when the control region, driven by the flow of an ODE, covers all the domain.

Equations with non-local spatial terms

In 10, we study the null controllability of the following linear heat equation with spatial non-local integral terms:



Under some analyticity assumptions on the corresponding kernel, we show that the equations is controllable. We employ compactness-uniqueness arguments in a suitable functional setting, an argument that is harder to apply for heat equations because of its very strong time irreversibility.

These mentioned results have been later improved in [], where we adopted a Carleman approach which allowed us to remove the (strong) analitycity assumptions on the kernel, and to replace them with sharp exponential decay conditions at the extrema of the time domain considered.

Models with memory terms

In 11, we approach the control problem for the following heat equation with lower order memory



This can be rewritten as a system coupling a heat equation with an ordinary differential equation, as in the context of viscoelasticity. In view of this structure we introduce a Moving geometric Control Condition (MGCC), which turns out to be sufficient for moving control. Furthermore, in (10) we obtain similar results for the following wave equation with a lower order memory term



while in 7 we were able to address the case of the following one-dimensional wave equation with memory in the principal part


Perspectives


  Weakening the MGCC for the control of viscoelasticity models.
  Models with fractional time derivatives: what kind of control theoretical properties can be expected once exact controllability is excluded?
  General analytic memory kernels.
  Geometric Optics for wave-like models involving the fractional Laplacian.
  Can Carleman inequalities handle non-local terms?
  Links with delay systems.
  Nonlinear models.


References


  
    
      G.~Lu - “The Peierls-Nabarro model of dislocations: a venerable theory and its current development” - Handbook of Materials Modeling, 2005 &amp;#8617;
    
    
      G.~Gilboa and S.~Osher - “Nonlocal operators with applications to image processing” - Multiscale Model Simul., 2008 &amp;#8617;
    
    
      M.~Bologna, C.~Tsallis and P. Grigolini - “Anomalous diffusion associated with nonlinear fractional derivative Fokker-Plank-like equation: exact time-time dependent solutions” - Phys. Rev., 2000 &amp;#8617;
    
    
      S.~Levendorski - “Pricing of the American put under Levy processes” - Int. J. Theor. Appl. Finance, 2004 &amp;#8617;
    
    
      Q.~L&quot;u and E. Zuazua - “On the lack of controllability of fractional in time ODE and PDE” - Math. Control Signals Syst., 2016 &amp;#8617;
    
    
      U.~Biccari - “Internal control for non-local Schr&quot;odinger and wave eqautions involving the fractional Laplace operator” - Submitted &amp;#8617;
    
    
      U.~Biccari, and Aceves, A. B. WKB expansion for a fractional Schröodinger equation with applications to controllability. Submitted. (2018). &amp;#8617; &amp;#8617;2
    
    
      T.H.~Banks, S.~Hu and Z.R.~Kenz - “A brief review of elasticity and viscoelasticity for solids} - Adv. Appl. Math. Mech., 2011.” &amp;#8617;
    
    
      F.~Chaves, L.~Rosier and E.~Zuazua - “Null controllability of a system of viscoelasticity with moving control” - J. Math. Pures Appl., 2014. &amp;#8617;
    
    
      Q.~L&quot;u, X.~Zhang and E. Zuazua - “Null controllability of wave equations with memory” - Submitted &amp;#8617; &amp;#8617;2
    
    
      F.~Chaves, X.~Zhang and E.~Zuazua - “Controllability of evolution equations with memory” - Submitted &amp;#8617;
    
  

</description>
        <pubDate>Mon, 01 Oct 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/posts/Control_of_PDE_non_local_terms</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/posts/Control_of_PDE_non_local_terms</guid>
        
        
        <category>Posts</category>
        
      </item>
    
      <item>
        <title>Rays propagation of a fractional Schrodinger Equation</title>
        <description>Shows the propagation of the solution of a fractional Schrodinger equation with concentrated and highly oscillatory initial datum. The solution remains concentrated along the rays of geometric optics

N = 250;
L = 1;
hx = (2*L)/(N+1);


Definition of the initial datum u0 as a function_handle. u0 is chosen as a Gaussian profile multiplied by a higly oscillatory function

x0 = 0; % Center of the Gaussian profile
gamma = hx^(-0.9); % Amplitude of the Gaussian profile
fr = (1/hx)*pi^2/16; % Frequency of the oscillations


u0 = @(x) exp(-0.5*gamma*(x-x0).^2).*exp(1i*fr*x);


Plot of the initial datum

fig = gcf;
set(gcf,'Units','pixels','Position',[427 306 712 284])

x = -L:hx:L;

subplot(1,3,1) % Modulus
plot(x,abs(u0(x)))
title('|u_0(x)|')
xlabel('x'); ylabel('u(x)');

subplot(1,3,2) % Real part
plot(x,real(u0(x)))
title('real(u_0(x))')
xlabel('x'); ylabel('u(x)');

subplot(1,3,3) % Imaginary part
plot(x,imag(u0(x)))
title('img(u_0(x))')
xlabel('x'); ylabel('u(x)');

format_plot(fig)




Solution for s = 1/2

Define the characteristic parameters of the problem

s = 0.5  % Order of the fractional Laplacian
L        % Extrema of the space interval
N        % Number of points in the space mesh
T = 5    % Length of the time interval
u0       % The function_handle that we have showed before.



s =

    0.5000


L =

     1


N =

   250


T =

     5


u0 =

  function_handle with value:

    @(x)exp(-0.5*gamma*(x-x0).^2).*exp(1i*fr*x)




To solve the equation, we call the function fractional_schr. The solution of the equation is stored in the u variable.

[x,t,u] = fractional_schr(s,L,N,T,u0);


Now we can see a graphical interpretation

[X,T] = meshgrid(x,t);
%
clf
mesh(X,T,u');
format_plot(gcf);view(0,90)
xlabel('x'); ylabel('t'); title('Ray Evolution');




By typing “animation(x,t,u)” in the MATLAB console you can see the evolution in time of this wave.



</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp05/P0001-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp05/P0001-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP05</category>
        
      </item>
    
      <item>
        <title>Average Control by classical gradient step method</title>
        <description>In this work, we address the optimal control of parameter-dependent systems. We introduce the notion of averaged control in which the quantity of interest is the average of the states with respect to the parameter family 

In this case $\nu_i$ are:

nu = 1:0.5:6



nu =

  Columns 1 through 7

    1.0000    1.5000    2.0000    2.5000    3.0000    3.5000    4.0000

  Columns 8 through 11

    4.5000    5.0000    5.5000    6.0000




And save in K, the number of values

K = length(nu);


Where the finite dimensional linear control system is:



We can, define the initial state of all ode’s

N = 3; % dimension of vector state
x0 = ones(N, 1);


Also, need define a initial control, that will be evolve

dt = 0.02;
t0 = 0; T  = 1;
span = (t0:dt:T);
%
u = zeros(length(span),1);


%Moreover, we can define the matrix A's and B's, that determine the problem
Am = -triu(ones(N))



Am =

    -1    -1    -1
     0    -1    -1
     0     0    -1




Bm = zeros(N, 1);
Bm(N) = 1



Bm =

     0
     0
     1




So, we can create these edo’s in variable primal_odes.

primal_odes = zeros(1,K,'ode');
for index = 1:K
    A = Am + (nu(index) - 1 )*diag(diag(Am));
    %
    primal_odes(index) = ode(A,'B',Bm);
    % all have the same control
    primal_odes(index).u  = u;
    % time intervals
    primal_odes(index).span = span;
    % initial state
    primal_odes(index).x0 = x0;
end


So, we have a $K$ ordinary differential equations

primal_odes



primal_odes = 

  1x11 ode array with properties:

    A
    B
    u
    x0
    x
    span
    xend




To solve average control problem to x0; in this case:

xt = ones(N, 1)



xt =

     1
     1
     1




we can solve the minimization problem



We can use the classical gradient descent method based on the adjoint methodology, and obtain the corresponding adjoint system for 1,



The same way that before, we define the adjoints problems

adjoint_odes = zeros(1,K,'ode');
for index = 1:K
    A = primal_odes(index).A';
    adjoint_odes(index) = ode(A);
    % all have the same control
    adjoint_odes(index).u = u;
    % time intervals
    adjoint_odes(index).span = span;
end


However the initial state  adjoint_odes(index).x0 hasn’t been assign. This initial state will be assign in every step of solution.

To minimize the functional, $\mathcal{J}\left( u\right)$, we take the steepest descent direction given by



We process to solve the problem of classical gradient descent

gamma = 1;
beta  = 1e-3;
tol   = 1e-8;  % Tolerance
error = Inf;
MaxIter = 50;
iter = 0;
xhistory = {}; uhistory = {};  error_history = [];    % array here we will save the evolution of average vector states
while (error &amp;gt; tol &amp;amp;amp;&amp;amp;amp; iter &amp;lt; MaxIter)
    iter = iter + 1;
    % solve primal problem
    % ====================
    solve(primal_odes);
    % calculate mean state final vector of primal problems
    xMend = forall({primal_odes.xend},'mean');

    % solve adjoints problems
    % =======================
    % update new initial state of all adjoint problems
    for iode = adjoint_odes
        iode.x0 = -(xMend' - xt);
    end
    % solve adjoints problems with the new initial state
    solve(adjoint_odes);

    % update control
    % ===============
    % calculate mean state vector of adjoints problems
    pM = forall({adjoint_odes.x},'mean');
    pM = pM*Bm;

    % reverse adjoint variable
    pM = flipud(pM);
    % Control update
    u = primal_odes(1).u; % catch control currently
    Du = beta*u - pM;
    u = u - gamma*Du;
    % update control in primal problems
    for index = 1:K
        primal_odes(index).u = u;
    end
    % Control error
    % =============
    % Calculate area ratio  of Du^2 and u^2
    Au2   =  trapz(span,u.^2);
    ADu2  =  trapz(span,Du.^2);
    %

    error = sqrt(ADu2/Au2);
    % Save evolution
    xhistory{iter} = [ span',forall({primal_odes.x},'mean')];
    uhistory{iter} = [ span',u];
    error_history  = [ error_history, error];
end


The average control obtain is

plot(span,u)
xlabel('time');ylabel('u(t)')
format_plot(gcf)




Also, on average the objective [0 0 0] has been reached.

figure;
plot(iode.span,forall({primal_odes.x},'mean'))
xlabel('t');ylabel('x_{i}(t)')
legend(strcat('x_{',num2str((1:N)','%0.1d'),'}(t)'))
title('Evolution of cordinates of vector state.')
format_plot(gcf)




You can use the comand

animation_sol(xhistory,uhistory,'XLim',[-0.1 0.25],'ULim',[-0.5 0.0])

We can see 

If we analyze the evolution in the error, we can see that we should have stopped, in iteration 20.

plot(error_history,'-*')
title('Error Evolution')
ylabel('Error'); xlabel('Iterations')
format_plot(gcf)




References


  
    
      E. Zuazua (2014) Averaged Control. Automatica, 50 (12), p. 3077-3087. &amp;#8617;
    
  

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp01/P0001-T</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/tutorials/wp01/P0001-T</guid>
        
        
        <category>Tutorials</category>
        
        <category>WP01</category>
        
      </item>
    
      <item>
        <title>rigidity_fr_laplacian</title>
        <description>

Description

Summary of example objective

Section 1 Title

Description of first code block

a = 1;


Section 2 Title

Description of second code block

b = 2;


</description>
        <pubDate>Sat, 01 Apr 2017 00:00:00 +0200</pubDate>
        <link>https://DeustoTech.github.io/dycon-platform-documentation/functions/rigidity_fr_laplacian-F</link>
        <guid isPermaLink="true">https://DeustoTech.github.io/dycon-platform-documentation/functions/rigidity_fr_laplacian-F</guid>
        
        
        <category>Functions</category>
        
      </item>
    
  </channel>
</rss>
