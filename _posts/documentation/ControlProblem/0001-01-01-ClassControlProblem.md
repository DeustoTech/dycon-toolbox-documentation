---
description: This class is able to solve optimization problems of a function restricted to an ordinary equation. This scheme is used to solve optimal control problems in which the functional derivative is calculated. <strong>ControlProblem</strong> class has methods that
              help us find optimal control as well as obtaining the attached problem and it's derivative form, 
              in both symbolic and numerical versions.
visible: true
title: ControlProblem
categories: [documentation, MDL01]
layout: class
type: constructor
properties:
   Jfun: 
        type: "Functional"
        default: "none"
        description: "This property represent the cost of optimal control"
      
   ode: 
        type: ode
        default: none
        description: This property represented ordinary differential equation
      
   T: 
        type: double
        default: 1
        description: Final Time of simulation 
      
   dt: 
        type: double
        default: iode.dt
        description: Sampling in time of interpolation of calculate the functional value
      
   UOptimal: 
        type: double
        default: none
        description: It is the optimal control of problem. This property only can be set by GradientMethod.
      
   precision: 
        type: double
        default: none
        description: Precision is a umber that is generated by solvers. This number incidcate the precision of solution obj.UOptimal
      
   P: 
        type: double
        default: none
        description: Symbolic vector that represent the co-state of ode. $ \textbf{P} = (p_1 ,p_2,... )$       
      
   adjoint: 
        type: struct
        default: none
        description: The adjoint propertir contain the numerical function that represents the adjoint problem this struct have a two properties. The first is dP_dt and the second is P0.
      
   dH_du: 
        type: double
        default: function_handle
        description: The derivative of the Hamiltonian with respect to the control u         
      
   Jhistory: 
        type: double
        default: none
        description: It is an array that contains the different functional values during the execution of the optimization algorithm that has been used.
      
   Yhistory: 
        type: cell
        default: none
        description: It is an cell that contains the different solutions of state, $Y$, during the execution of the optimization algorithm that has been used.        
      
   Uhistory: 
        type: double
        default: none
        description: It is an array that contains the different control, $U$, values during the execution of the optimization algorithm that has been used.
      
   iter: 
        type: double
        default: none
        description: number of iterations that the algorithm has made
      
   time: 
        type: double
        default: none
        description: Time it took the optimization algorithm to execute.
      
methods:
   ControlProblem:
        name: ControlProblem
        description: 
        autor: JOroya
        MandatoryInputs:   
          iode: 
              name: Ordinary Differential Equation 
              description: Ordinary Differential Equation represent the constrain to minimization the functional 
              class: ode
              dimension: [1x1]
          Jfun: 
              name: functional
              description: Cost function to obtain the optimal control 
              class: Functional
              dimension: [1x1]        
        OptionalInputs:
          T:
              name: Final Time 
              description: This parameter represent the final time of simulation.  
              class: double
              dimension: [1x1]
              default: iode.T 
          dt:
              name: Final Time 
              description: This parameter represent is the interval to interpolate the control, $u$, and state, $y$, to obtain the functional $J$ and the gradient $dH/du$
              class: double
              dimension: [1x1]
              default: iode.dt         
        Outputs:
          obj:
              name: ControlProblem MATLAB
              description: ControlProblem MATLAB class
              class: ControlProblem
              dimension: [1x1]
        url: /documentation/mdl01/ControlProblem/ControlProblem
   ClassicalDescent:
         description: This method is able to update the value of the control by decreasing 
                      the value of the functional. By calculating the gradient, $ \frac{dH}{du}$. Also, it is decremented 
                      in that direction, assuring the decrease by the adaptive step size. 
         little_description: This method is able to update the value of the control by decreasing the value of the functional. 
         autor: JOroya
         MandatoryInputs:   
           iCP: 
               description: Control Problem Object
               class: ControlProblem
               dimension: [1x1]
           UOld: 
               description: Control Vector in time  
               class: double
               dimension: [M,iCP.tline]
           YOld: 
               description: State Vector in time 
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
           JOld: 
               description: Value of functional J(Uold,Yold)
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
         OptionalInputs:
           InitialLengthStep: 
               description: This parameter is the step size if the MiddleStepControl option is false. 
                              If the option MiddleStepControl is activated then this parameter is the initial step
                              of the methodo but then the step is doubled in the case where the functional iteration 
                              decreases and is divided by two its the functional one grows.
               class: double
               dimension: [1x1]
           MinLengthStep: 
               description: It may happen that although we divide the step of the descenco many times,
                              we continue to obtain an update that increases the value of the functional. In this case,
                              it is necessary to have a minimum step size to avoid infinite loops. This parameter is
                              responsible for this.
               class: double
               dimension: [1x1]
           MiddleStepControl: 
               description: If this parameter is enabled, it allows the algorithm to search for different 
                              step-logitudes, provided that the control update decrements the functional value. If it is
                              deactivated, the descent of the gradient will be constant.
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
         Outputs:
           Unew:
               description: Update of Control Vector  
               class: double
               dimension: [Mxlength(iCP.tline)]
           Ynew:
               description: Update of State Vector 
               class: double
               dimension: [length(iCP.tline)]
           Jnew:
               description: New Value of functional 
               class: double
               dimension: [1x1]
         url: /documentation/mdl01/ControlProblem/ClassicalDescent
   GetAdjointProblem:
        description: This method adds the problem adjoint to the Control Problem object, since we have
                      $$ \dot{\textbf{Y}} = f(\textbf{Y},t) $$ 
                      and the functional
                      $$ J = \Psi(\textbf{Y}(T)) + \int_{0}^T L(\textbf{Y},U,t)dt $$ 
                      we can create the Hamiltonian 
                      $$ H = L + P*F $$
                      where $\textbf{P} = [p_1 p_2 p_3 ... ]^T$ . So according to the principle of the maximum of pontriagin,
                      we can calculate the attached problems through the formulas
                      $$ \frac{d\textbf{P}}{dt} = \vec{\nabla}_{Y} H = 
                      (\frac{\partial H}{ \partial y_1},\frac{\partial H}{ \partial y_2},...)$$
                      with the final time condition
                      $$ \textbf{P}(T) = 
                      (\frac{\partial \Psi}{ \partial y_1},\frac{\partial \Psi}{ \partial y_2},...)$$
        little_description: Method capable of obtaining the attached problem and its final condition.
        autor: JOroya
        MandatoryInputs:   
           iCP: 
               name: Control Problem
               description: Control problem object
               class: ControlProblem
               dimension: [1x1]
        url: /documentation/mdl01/ControlProblem/GetAdjointProblem
   GetFunctional:
        description: Method capable of calculating the value of the functional defined in the control problem.
        little_description: Method capable of calculating the value of the functional defined in the control problem.
        autor: JOroya
        MandatoryInputs:   
         iCP: 
           description:  Control Problem
           class: ControlProblem
           dimension: [1x1]
         Y: 
           name: Solution of ODE
           description: 
           class: ControlProblem
           dimension: [1x1]
         U: 
           name: matrix of control
           description: 
           class: ControlProblem
           dimension: [1x1]
        Outputs:
         JValue:
           name: Functional value with this U and Y 
           description: double 
           class: double
           dimension: [1x1]
        url: /documentation/mdl01/ControlProblem/GetFunctional
   GetGradient:
        description: Creates the iCP.dH_du property that contains a numeric function that 
                      returns the value of the gradient given the dynamics solution, 
                      $Y$ and the associated control, $U$.
        little_description: Creates the iCP.dH_du property that contains a numeric function that 
                      returns the value of the gradient given the dynamics solution, 
                      $Y$ and the associated control, $U$. 
        autor: JOroya
        MandatoryInputs:   
         iCP: 
           name: Control Problem
           description: 
           class: ControlProblem
           dimension: [1x1]
        url: /documentation/mdl01/ControlProblem/GetGradient
   GradientMethod:
        name: GradientMethod
        description: The gradient method is able to optimize the given functional, going down the gradient.
        little_description: The gradient method is able to optimize the given functional, going down the gradient.
        autor: JOroya
        MandatoryInputs:   
          iCP: 
              name: Control Problem
              description: 
              class: ControlProblem
              dimension: [1x1]
        OptionalInputs:
          U0:
              name: Initial Control 
              description: matrix 
              class: double
              dimension: [length(iCP.tline)]
              default: zeros
          MaxIter:
              name: Initial Control 
              description: matrix 
              class: double
              dimension: [1x1]
              default: 50
          tol:
              name: Initial Control 
              description: matrix 
              class: double
              dimension: 
              dimension: [1x1]
          DescentParameters:
              description: Parmater of Descent Method 
              class: double
              dimension: cell
              default: cell.empty    
          Graphs:
              description: Parameter that indicate if the method must plot the optimization, while is calculate 
              class: logical
              dimension: [1x1]
              default: false        
          TypeGraphs:
              description: Type of graphs. This parameter can be 'ODE' or 'PDE' 
              class: string
              dimension: [1x1]
              default: 'ODE'
          SaveGif:
              name: If this parameter is true, A gif of the optimization process is created
              description: matrix 
              class: double
              dimension: [length(iCP.tline)]
              default: false
          restart:
              description: The optimization start with U0 = iCP.UOptimal
              class: double
              dimension: [1x1]
              default: false
        url: /documentation/mdl01/ControlProblem/GradientMethod
   plot:
        name: GradientMethod
        description: Since most of the optimization methods require an iterative process, plot shows how the dynamics, 
                      the control and the functional in the optimization evolve.
        little_description: shows how the dynamics, the control and the functional in the optimization evolve.
        autor: JOroya
        MandatoryInputs:   
          iCP: 
              name: Control Problem
              description: 
              class: ControlProblem
              dimension: [1x1]
        OptionalInputs:
          Graphs:
              description: Parameter that indicate if the method must plot the optimization, while is calculate 
              class: logical
              dimension: [1x1]
              default: false        
          TypeGraphs:
              description: Type of graphs. This parameter can be 'ODE' or 'PDE' 
              class: string
              dimension: [1x1]
              default: 'ODE'
          SaveGif:
              name: If this parameter is true, A gif of the optimization process is created
              description: matrix 
              class: double
              dimension: [length(iCP.tline)]
              default: false
        url: /documentation/mdl01/ControlProblem/plot
   resume:
        description: show the most importants parameters of the control problem
        little_description: show the most importants parameters of the control problem
        autor: JOroya
        MandatoryInputs:   
           iCP: 
               description: Control Problem Object
               type: ControlProblem
        url: /documentation/mdl01/ControlProblem/resume

---

First define the vectors


$$ symY = \left( \begin{matrix}   y1 \\                                   y2                  \end{matrix} \right)    symU = \left( \begin{matrix}   u1 \\                                   u2                   \end{matrix} \right) $$

```matlab
clear;
syms t
symY = SymsVector('y',2);
symU = SymsVector('u',1);
```


**Cost Functional**


$$ J = \Psi(Y(T),t) + \int_0^T L(Y(t,U),U(t),t) dt$$

```matlab
A = 10;
symPsi  = 0;
symL    = A*(symU.'*symU) + symY(2);
```

```matlab
Jfun = Functional(symPsi,symL,symY,symU);
```


**Ordinary differential equation**


In this case we will define the following differential equation


$$ \left( \begin{matrix}   \dot{S} \\                            \dot{I}                  \end{matrix} \right)    =       \left( \begin{matrix}   \lambda - \beta S I - \sigma_1 S \\                               \beta S I - u_1 I - \sigma_2 I                   \end{matrix} \right) $$

```matlab
Lambda = 1;beta = 0.5;
sigma1 = 0.1;sigma2 = 0.1;

S = symY(1);I = symY(2);
Fsym(1)  = Lambda - beta*S*I -  sigma1*S;
Fsym(2)  = beta*S*I - symU(1)*I - sigma2*I ;
%
Fsym = Fsym.'
```


```
 
Fsym =
 
     1 - (y1*y2)/2 - y1/10
 (y1*y2)/2 - u1*y2 - y2/10
 

```

```matlab
T = 20;
S0 = 100 ;I0 = 15;
Y0 = [ S0 ; I0];
odeEqn = ode(Fsym,symY,symU,'Y0',Y0,'T',T);
```


Now, We can create the control problem

```matlab
iCP1 = ControlProblem(odeEqn,Jfun);
```


```
Warning: The parameter T (final time), is different in Jfunction and ODE
problem. We use ODE.T for all. 

```


and solve by Classical Gradient Method

```matlab
DescentParameters = {'MiddleStepControl',true,'InitialLengthStep',1e-5,'MinLengthStep',1e-10};
Gradient_Parameters = {'maxiter',50,'DescentParameters',DescentParameters};
%
GradientMethod(iCP1,Gradient_Parameters{:})
```

```matlab
plot(iCP1)
```


![]({{site.url}}/{{site.baseurl}}/assets/imgs/MDL01/class/main/ControlProblem/copiaRM_01.png)

