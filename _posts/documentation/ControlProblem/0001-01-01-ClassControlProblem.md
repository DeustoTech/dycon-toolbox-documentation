---
description: This class is able to solve optimization problems of a function restricted to an ordinary differential equation. This scheme is used to solve optimal control problems in which the functional derivative is calculated. <strong>ControlProblem</strong> class has methods that help us find optimal control as well as obtaining the attached problem and it's derivative form, in both symbolic and numerical versions.
title: ControlProblem
categories: [documentation, MDL01]
layout: class
type: constructor
properties:
   Jfun: 
      type: "Functional"
      default: "none"
      description: "This property represent the cost of optimal control"
   ode: 
      type: ode
      default: none
      description: This property represented ordinary differential equation
   T: 
      type: double
      default: 1
      description: Final Time of simulation
   dt: 
      type: double
      default: iode.dt
      description: Sampling in time of interpolation of calculate the functional value
   UOptimal: 
      type: double
      default: none
      description: It is the optimal control of problem. This property only can be set by GradientMethod.
   precision: 
      type: double
      default: none
      description: Precision is a umber that is generated by solvers. This number incidcate the precision of solution obj.UOptimal
   P: 
      type: double
      default: none
      description: Symbolic vector that represent the co-state of ode. $ \textbf{P} = (p_1 ,p_2,... )$
   adjoint: 
      type: struct
      default: none
      description: The adjoint propertir contain the numerical function that represents the adjoint problem this struct have a two properties. The first is dP_dt and the second is P0.
   dH_du: 
      type: double
      default: function_handle
      description: The derivative of the Hamiltonian with respect to the control u
   Jhistory: 
      type: double
      default: none
      description: It is an array that contains the different functional values during the execution of the optimization algorithm that has been used.
   Yhistory: 
      type: cell
      default: none
      description: It is an cell that contains the different solutions of state, $Y$, during the execution of the optimization algorithm that has been used.
   Uhistory: 
      type: double
      default: none
      description: It is an array that contains the different control, $U$, values during the execution of the optimization algorithm that has been used.
   iter: 
      type: double
      default: none
      description: number of iterations that the algorithm has made
   time: 
      type: double
      default: none
      description: Tiempo que ha tardado el algoritmo de optimizaciï¿½n en ejecutarse.
methods:
   ControlProblem:
        name: ControlProblem
        description: 
        autor: JOroya
        MandatoryInputs:   
          iode: 
              name: Ordinary Differential Equation 
              description: Ordinary Differential Equation represent the constrain to minimization the functional 
              class: ode
              dimension: [1x1]
          Jfun: 
              name: functional
              description: Cost function to obtain the optimal control 
              class: Functional
              dimension: [1x1]        
        OptionalInputs:
          T:
              name: Final Time 
              description: This parameter represent the final time of simulation.  
              class: double
              dimension: [1x1]
              default: iode.T 
          dt:
              name: Final Time 
              description: "This parameter represent is the interval to interpolate the control u and state y to obtain the functional J and the gradient dH/du"
              class: double
              dimension: [1x1]
              default: iode.dt         
        Outputs:
          obj:
              name: ControlProblem MATLAB
              description: ControlProblem MATLAB class
              class: ControlProblem
              dimension: [1x1]
        url: /documentation/MDL01/ControlProblem/ControlProblem
   ClassicalDescent:
         description: This method is able to update the value of the control by decreasing 
                      the value of the functional. By calculating the gradient, $ \frac{dH}{du}$. Also, it is decremented 
                      in that direction, assuring the decrease by the adaptive step size. 
         autor: JOroya
         MandatoryInputs:   
           iCP: 
               description: Control Problem Object
               class: ControlProblem
               dimension: [1x1]
           UOld: 
               description: Control Vector in time  
               class: double
               dimension: [M,iCP.tline]
           YOld: 
               description: State Vector in time 
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
           JOld: 
               description: Value of functional J(Uold,Yold)
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
         OptionalInputs:
           InitialLengthStep: 
               description: This parameter is the step size if the MiddleStepControl option is false. 
                              If the option MiddleStepControl is activated then this parameter is the initial step
                              of the methodo but then the step is doubled in the case where the functional iteration 
                              decreases and is divided by two its the functional one grows.
               class: double
               dimension: [1x1]
           MinLengthStep: 
               description: It may happen that although we divide the step of the descenco many times,
                              we continue to obtain an update that increases the value of the functional. In this case,
                              it is necessary to have a minimum step size to avoid infinite loops. This parameter is
                              responsible for this.
               class: double
               dimension: [1x1]
           MiddleStepControl: 
               description: If this parameter is enabled, it allows the algorithm to search for different 
                              step-logitudes, provided that the control update decrements the functional value. If it is
                              deactivated, the descent of the gradient will be constant.
               class: double
               dimension: [length(iCP.ode.Y0),iCP.tline]
         Outputs:
           Unew:
               description: Update of Control Vector  
               class: double
               dimension: [Mxlength(iCP.tline)]
           Ynew:
               description: Update of State Vector 
               class: double
               dimension: [length(iCP.tline)]
           Jnew:
               description: New Value of functional 
               class: double
               dimension: [1x1]
         url: /documentation/MDL01/ControlProblem/ClassicalDescent
   GetAdjointProblem:
        little_description: Metodo capaz de calcular el problema adjunto de la ecuacion diferencial atravez del hamiltoniano
                             asociado (Principi de Pontriagin). Mediante la formula $ \frac{d\textbf{P}}{dt} = \vec{\nabla}_{Y} H $
        description: Este metodo agrega el problema adjunto al objecto ControlProblem, dado que tenemos 
                      $$ \dot{\textbf{Y}} = f(\textbf{Y},t) $$ 
                      y el funcional 
                      $$ J = \Psi(\textbf{Y}(T)) + \int_{0}^T L(\textbf{Y},U,t)dt $$ 
                      podemos crear el Hamiltoniano 
                      $$ H = L + P*F $$
                      donde $\textbf{P} = [p_1 p_2 p_3 ... ]^T$ . Entonces 
                      segun el principio del maximo de pontriagin 
                      podemos calcular el problemas adjunto mediantes las formulas 
                      $$ \frac{d\textbf{P}}{dt} = \vec{\nabla}_{Y} H = 
                      (\frac{\partial H}{ \partial y_1},\frac{\partial H}{ \partial y_2},...)$$
                      con la condicion final 
                      $$ \textbf{P}(T) = 
                      (\frac{\partial \Psi}{ \partial y_1},\frac{\partial \Psi}{ \partial y_2},...)$$
        autor: JOroya
        MandatoryInputs:   
           iCP: 
               name: Control Problem
               description: Control problem object
               class: ControlProblem
               dimension: [1x1]
        Outputs:
           iCP: 
               name: Control Problem
               description: Control problem object
               class: ControlProblem
               dimension: [1x1]
        url: /documentation/MDL01/ControlProblem/GetAdjointProblem
   GetFunctional:
        description: Metodo de Es
        autor: Xinlung
        MandatoryInputs:   
         iCP: 
           name: Control Problem
           description: 
           class: ControlProblem
           dimension: [1x1]
        OptionalInputs:
         U0:
           name: Initial Control 
           description: matrix 
           class: double
           dimension: [length(iCP.tline)]
           default:   empty
        Outputs:
         U0:
           name: Initial Control 
           description: matrix 
           class: double
           dimension: [length(iCP.tline)]
           default:   empty
        url: /documentation/MDL01/ControlProblem/GetFunctional
   GetGradient:
        description: Metodo de Es
        autor: JOroya
        MandatoryInputs:   
        iCP: 
           name: Control Problem
           description: 
           class: ControlProblem
           dimension: [1x1]
        OptionalInputs:
        U0:
           name: Initial Control 
           description: matrix 
           class: double
           dimension: [length(iCP.tline)]
           default:   empty
        url: /documentation/MDL01/ControlProblem/GetGradient
   GradientMethod:
        name: GradientMethod
        description: Metodo de Es
        autor: JOroya
        MandatoryInputs:   
          iCP: 
              name: Control Problem
              description: 
              class: ControlProblem
              dimension: [1x1]
        OptionalInputs:
          U0:
              name: Initial Control 
              description: matrix 
              class: double
              dimension: [length(iCP.tline)]
              default:
        url: /documentation/MDL01/ControlProblem/GradientMethod
   plot:
        name: GradientMethod
        description: Metodo de Es
        autor: JOroya
        MandatoryInputs:   
          iCP: 
              name: Control Problem
              description: 
              class: ControlProblem
              dimension: [1x1]
        OptionalInputs:
          U0:
              name: Initial Control 
              description: matrix 
              class: double
              dimension: [length(iCP.tline)]
              default:
        url: /documentation/MDL01/ControlProblem/plot

---
```matlab
clear;
```


first define symbolics vectors:


$$ symY = \left( \begin{matrix}   y1 \\                                   y2                  \end{matrix} \right) $$


$$ symU = \left( \begin{matrix}   u1 \\                                   u2                   \end{matrix} \right) $$


We will use symbolic variables to define them.

```matlab
syms t
symY = SymsVector('y',2);
symU = SymsVector('u',2);
```


In this case we will define the following differential equation

```matlab
Y0 = [  0; ...
        1 ] ;
%
A = [ -1  1  ;  ...
       0 -2 ];
%
B = [  1 0; ...
       0 1 ];
```

```matlab
Fsym  = A*symY + B*symU;
```


To do this, we create an object differential equation. We can do it with the ODE constructor, in the following way:

```matlab
odeEqn = ode(Fsym,symY,symU,Y0);
```


Create the Funcional

```matlab
YT = [ 1; ...
       4];

symPsi  = (YT - symY).'*(YT - symY);
symL    = 0.0001*(symU.'*symU);

Jfun = Functional(symPsi,symL,symY,symU);
```


Now can create the object ControlProblem

```matlab
iCP1 = ControlProblem(odeEqn,Jfun);
iCP1
```


```

iCP1 = 

  ControlProblem with properties:

         Jfun: [1x1 Functional]
          ode: [1x1 ode]
            T: 1
           dt: 0.1000
     UOptimal: []
    precision: []
            P: [1x2 sym]
      adjoint: [1x1 struct]
        dH_du: @(t,Y,P,U)fcn(t,Y(1),Y(2),P(1),P(2),U(1),U(2))
     Jhistory: []
     Yhistory: []
     Uhistory: []
         iter: []
         time: []


```


Solve Gradient

```matlab
GradientMethod(iCP1)
```

