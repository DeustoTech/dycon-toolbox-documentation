---
title: Optimal control of a  graph evolving in discrete time
description: blabla.
date: 2018-10-26
author: [DomenecR]
layout: tutorial
matlab: T0004_SemiLinearControl
categories: [tutorial,TP02]
---
```matlab
clear all;
close all;
```

## Semi-linear semi-discrete heat equation and collective behavior

```matlab
\% In this tutorial we will apply the DyCon toolbox to find a control to the
\% semi-discrete semi-linear heat equation.
```


$$y_t-N^2Ay=G(y)+Bu$$


where $N^2A$ is the discretization of the Laplacian in 1d in $N$ nodes. We are looking for a control that after time $T$ steers the system near zero. In order to do so we will frame the problem as a minimization of a functional and we will apply gradient descent to find it. Note that the convexity of the fuctional is not proven, therefore, we will obtain a local minima for the functional. The functional considered will be:


$$J(\boldsymbol{y},\boldsymbol{u})=|\boldsymbol{y}(t)|_{L^2}^2+\int_0^T `\boldsymbol{u}(t)`_{L^2}^2 dt$$


where by $|\cdot|_^{L^2}$ we understand the discrete $L^2$ norm.


We shall see the control for different mesh-sizes, the number of nodes will take this three possible values N=15,25,50.


Once this control is computed for each N, we will think on a dynamical system that models an opinion dynamics with $N$ agents communicating through a chain.


$$y_t-\frac{1}{N}Ay=G(y)+Bv$$

## We set for which $N$ are we going to apply the method

```matlab
Ns=[11,12];
\%Ns=[15,25];
norms=zeros(1,length(Ns));
targnorms=zeros(1,length(Ns));
Size=size(norms)
```


```

Size =

     1     2


```

## We initialize the loop

```matlab
for k=1:Size(2)
```

## Definition of the time

```matlab
syms t
```

## Discretization of the space

```matlab
N = Ns(k);
xi = 0; xf = 1;
xline = linspace(xi,xf,N);
```

## Interior Control region between 0.5 and 0.8

```matlab
w1=0.5;
w2=0.8;
```


Here we count how many elements in the discretization should be placed inside the control region

```matlab
count=1;
for i=1:N
    if (double(i-1))/double(N) > w1
        if (i-1)/double(N) < w2
            count=count+1;
        end
    end
end
```


we define symbolically the vectors of the state and the control

```matlab
symY = SymsVector('y',N);
symU = SymsVector('u',count);
```

## We create the functional that we want to minimize


Our goal is to set the system to zero penalizing the norm of the control by a parameter $\beta$ that will be small.

```matlab
YT = 0*xline';
symPsi  = (YT - symY).'*(YT - symY);
\%symPsi  = 0;
beta=0.0000001;
\%symL    = (YT - symY).'*(YT - symY)+beta*(symU.'*symU)*(abs(w2-w1))/count;
symL    = beta*(symU.'*symU)*(abs(w1-w2))/count;

Jfun = Functional(symPsi,symL,symY,symU);
```

## We create the ODE object


Our ODE object will have the semi-discretization of the semilinear heat equation. We set also initial conditions, define the non linearity and the interaction of the control to the dynamics.

```matlab
\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\% Initial condition
Y0 = 2*sin(pi*xline)';
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%


\% Diffusion part: the discretization of the 1d Laplacian
A=(N^2)*(full(gallery('tridiag',N,1,-2,1)));
\%A=1./(N)*(full(gallery('tridiag',N,1,-2,1)));
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\%B = zeros(N,2);
\%B(1,1) = 1;
\%B(N,2) = 1;
```


We define the matrix B that will be the effect of the interior control to the dynamics

```matlab
B = zeros(N,count);
count2=1;
for i=1:N
    if (i-1)/double(N) >= w1
        if (i-1)/double(N) < w2
            B(i,count2)=1;
            count2=count2+1;
        end
    end
end
```


Definition of the non-linearity $$ \partial_y[-5\exp(-y^2)] $$

```matlab
syms x;
syms G(x);
syms U(x);
syms DG(x);
U(x)=-5*exp(-x^2);
G(x)=diff(U,x);
formula=G(x);
G = symfun(formula,x);
```


and we define the part of the dynamics corresponding to the nonlinearity

```matlab
vectorF = arrayfun( @(x)G(x),symY);
```


Putting all the things together

```matlab
Fsym  = A*symY + vectorF + B*symU;
```

## Creation of the ODE object


Time horizon

```matlab
T = 1;
```


We create the ODE-object and we change the resolution to dt=0.01 in order to see the variation in a small time scale. We will get the values of the solution in steps of size odeEqn.dt, if we do not care about modifying this parameter in the object, we might get the solution in certain time steps that will hide part of the dynamics.

```matlab
odeEqn = ode(Fsym,symY,symU,'Y0',Y0,'T',T);
odeEqn.dt=0.01;
```

## We solve the equation and we plot the free solution applying solve to odeEqn and we plot the free solution.

```matlab
solve(odeEqn)

figure;

surf(odeEqn.Y);

figure;
line(xline,YT,'Color','red')
line(xline,odeEqn.Y(end,:),'Color','blue')
legend('Target','Free Dynamics')
```


![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_01.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_02.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_06.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_07.png)


## We create the object that collects the formulation of an optimal control problem  by means of the object that describes the dynamics odeEqn, the functional to minimize Jfun and the time horizon T

```matlab
iCP1 = ControlProblem(odeEqn,Jfun,'T',T);
```

## We apply the steepest descent method to obtain a local minimum (our functional might not be convex).

```matlab
tol = 0.1;
maxiter = 30;
DescentParameters = {'MiddleStepControl',true,'InitialLengthStep',4.0};
GradientParameters = {'tol',tol,'DescentParameters',DescentParameters,'maxiter',maxiter};
\%
GradientMethod(iCP1,GradientParameters{:})

figure;
surf(iCP1.ode.Y)

figure;
surf(iCP1.UOptimal)

figure;
line(xline,YT,'Color','red')
line(xline,odeEqn.Y(end,:),'Color','blue')
line(xline,iCP1.ode.Y(end,:),'Color','green')
legend('Target','Free Dynamics','controlled dynamics')

uu=iCP1.UOptimal;
for j=1:size(1)
norms(k)=norms(k)+(uu(j,:)*uu(j,:)')*(abs(w1-w2))/count;
end
for j=size(iCP1.ode.Y(end,:))
targnorms(k)=targnorms(k)+iCP1.ode.Y(end,j)^2;
end
targnorms(k)/N;
```


![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_03.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_04.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_05.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_08.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_09.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_10.png)


```matlab
end
```

## Now we apply the same procedure for the collective behavior dynamics and we get the following results

```matlab
normscb=zeros(1,1);
targnormscb=zeros(1,1);
for k=1:1
```

## Los vectores symY = [ y1 y2 ]

## symU = [ u1 u2 ]

```matlab
syms t
```

## Discretization of the space

```matlab
N = Ns(k);
xi = 0; xf = 1;
xline = linspace(xi,xf,N);
```

## Control region between 0.5 and 0.6

```matlab
w1=0.5;
w2=0.8;

count=1;
for i=1:N
    if (double(i-1))/double(N) > w1
        if (i-1)/double(N) < w2
            count=count+1;
        end
    end
end


symY = SymsVector('y',N);
symU = SymsVector('u',count);
```

## We create the functional that we want to minimize


Our goal is to set the system to zero penalizing the norm of the control by a parameter $\beta$ that will be small.

```matlab
YT = 0*xline';
symPsi  = (YT - symY).'*(YT - symY);
\%symPsi  = 0;
beta=0.0000001;
\%symL    = (YT - symY).'*(YT - symY)+beta*(symU.'*symU)*(abs(w2-w1))/count;
symL    = beta*(symU.'*symU)*(abs(w1-w2))/count;

Jfun = Functional(symPsi,symL,symY,symU);
```

## We create the ODE object


Our ODE object will have the semi-discretization of the semilinear heat equation. We set also initial conditions, define the non linearity and the interaction of the control to the dynamics.

```matlab
\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\% Initial condition
Y0 = 2*sin(pi*xline)';
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%


\% Diffusion part
\%A=(N^2)*(full(gallery('tridiag',N,1,-2,1)));
A=1/(N)*(full(gallery('tridiag',N,1,-2,1)));
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\%B = zeros(N,2);
\%B(1,1) = 1;
\%B(N,2) = 1;

\% Effect of the interior control to the dynamics
B = zeros(N,count);
count2=1;
for i=1:N
    if (i-1)/double(N) >= w1
        if (i-1)/double(N) < w2
            B(i,count2)=1;
            count2=count2+1;
        end
    end
end


\% Definition of the non-linearity
a=5;
c=0.20;
\%syms G(x);
syms x;
syms G;

syms x;
syms G(x);
syms U(x);
syms DG(x);
U(x)=-5*exp(-x^2);
G(x)=diff(U,x);

formula=G(x);\%*(1/N^3);

G = symfun(formula,x);

\%G(x) = piecewise(x<=-a, -2*a^2*x*c-2*a*a*a*c, a<=x, -2*a*a*x*c+2*a*a*a*c, -a<x<a, -c*x*(x-a)*(x+a));
\%GF=@(x) double(G(x));

vectorF = arrayfun( @(x)G(x),symY);
\%vectorF = arrayfun( @(x)0,symY);


\% B=zeros(N,N);
\% count=0;
\% for i=ceil(Nx*w1):floor(Nx*w2)
\%     B(i,i)=1;
\%     count=count+1;
\% end
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%

\% Putting all the things together
Fsym  = A*symY + vectorF + B*symU;
\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%
\% Time horizon
T = 1;

\% We create the ODE-object and we change the resolution to dt=0.01 in order
\% to see the variation in a small time scale. We will get the values of the
\% solution in steps of size odeEqn.dt, if we do not care about
\% modifying this parameter in the object, we might get the solution in
\% certain time steps that will hide part of the dynamics.

odeEqn2 = ode(Fsym,symY,symU,'Y0',Y0,'T',T);
odeEqn2.dt=0.01;
```

## We solve the equation and we plot the free solution applying

## solve to odeEqn and we plot the free solution.

```matlab
solve(odeEqn2)

figure;
surf(odeEqn2.Y);


line(xline,YT,'Color','red')
line(xline,odeEqn2.Y(end,:),'Color','blue')
legend('Target','Free Dynamics')
```


![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_11.png)


## We create the object that collects the formulation of an optimal control problem

## by means of the object that describes the dynamics odeEqn, the functional to minimize Jfun and the time horizon T

```matlab
iCP2 = ControlProblem(odeEqn2,Jfun,'T',T);
```

## We apply the steepest descent method to obtain a local minimum (our functional might not be convex).

```matlab
tol = 0.1;
maxiter = 30;
DescentParameters = {'MiddleStepControl',true,'InitialLengthStep',4.0};
GradientParameters = {'tol',tol,'DescentParameters',DescentParameters,'graphs',true,'TypeGraphs','PDE','maxiter',maxiter};
\%
GradientMethod(iCP2,GradientParameters{:})

figure;
surf(iCP2.ode.Y)

figure;
surf(iCP2.UOptimal)


figure;
line(xline,YT,'Color','red')
line(xline,odeEqn2.Y(end,:),'Color','blue')
line(xline,iCP2.ode.Y(end,:),'Color','green')
legend('Target','Free Dynamics','controlled dynamics')

uu=iCP2.UOptimal;
for j=1:size(1)
normscb(k)=normscb(k)+(uu(j,:)*uu(j,:)')*(abs(w1-w2))/count;
end
for j=size(iCP2.ode.Y(end,:))
targnormscb(k)=targnormscb(k)+iCP2.ode.Y(end,j)^2;
end
targnormscb(k)/N;
```


![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_12.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_13.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_14.png)

![]({{site.url}}/{{site.baseurl}}/assets/imgs/TP02/T0004/copiaRM_15.png)


```matlab
end
\% Several ways to run
\% GradientMethod(iCP1)
\% GradientMethod(iCP1,'DescentParameters',DescentParameters)
\% GradientMethod(iCP1,'DescentParameters',DescentParameters,'graphs',true)
```


